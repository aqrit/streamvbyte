#include <stddef.h>  // size_t
#include <stdint.h> // uint8_t, uint16_t, uint32_t, uint64_t

#include "svb.h"
#include "svb_internal.h"


#if defined(__SSE4_1__) || defined(__AVX__)

#include <smmintrin.h> // SSE4.1 intrinsics

/// shuffle control masks...
/// bit[7] of each byte holds the length which is extracted w/pmovmskb
/// 0x40 is add to each byte to fixup bit[7] for use by pshufb
/// if bit[7] is set in src then pshufb will write a zero to dst
static const uint8_t svb0_dec_table[256*16] = {
	0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xCF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x0E, 0xCF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x0C, 0x0D, 0xCE, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xBF, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x0E, 0xBF, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xCD, 0xCE, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xCB, 0x0C, 0xCD, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x7F, 0xBF, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xCD, 0xBF, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x0C, 0x0D, 0xBF, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x0A, 0xCB, 0xCC, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x7F, 0x7F, 0xBF, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xCB, 0x7F, 0xBF, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x0A, 0xCB, 0xBF, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x08, 0x09, 0x0A, 0xCB, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x0E, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xCD, 0xCE, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xCB, 0x0C, 0xCD, 0x0E, 0x7F, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x7F, 0xBF, 0x7F, 0x7F, 0x0E, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xCD, 0xBF, 0x7F, 0x7F, 0x0E, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x0C, 0x0D, 0xBF, 0x7F, 0x0E, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x0A, 0xCB, 0xCC, 0x0D, 0x0E, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xBF, 0xBF, 0x7F, 0x7F, 0x0D, 0x0E, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x0C, 0x7F, 0xBF, 0x7F, 0x0D, 0x0E, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xCB, 0x0C, 0xBF, 0x7F, 0x0D, 0x0E, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xC9, 0xCA, 0xCB, 0x0C, 0x0D, 0x0E, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xBF, 0x7F, 0xBF, 0x7F, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x0A, 0xBF, 0xBF, 0x7F, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xC9, 0xCA, 0xBF, 0x7F, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xC7, 0x08, 0x09, 0xCA, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x7F, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xCD, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x0C, 0x0D, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x0A, 0xCB, 0xCC, 0x0D, 0x7F, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xBF, 0xBF, 0x7F, 0x7F, 0x0D, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x0C, 0x7F, 0xBF, 0x7F, 0x0D, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xCB, 0x0C, 0xBF, 0x7F, 0x0D, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xC9, 0xCA, 0xCB, 0x0C, 0x0D, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x7F, 0x7F, 0xBF, 0x7F, 0x0C, 0x0D, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xCB, 0x7F, 0xBF, 0x7F, 0x0C, 0x0D, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x0A, 0xCB, 0xBF, 0x7F, 0x0C, 0x0D, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x08, 0x09, 0x0A, 0xCB, 0x0C, 0x0D, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x7F, 0xBF, 0xBF, 0x7F, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xC9, 0xBF, 0xBF, 0x7F, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x08, 0x09, 0x7F, 0xBF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x06, 0xC7, 0x08, 0xC9, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x7F, 0x7F, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xCB, 0x7F, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x0A, 0xCB, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x08, 0x09, 0x0A, 0xCB, 0x7F, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xBF, 0x7F, 0xBF, 0x7F, 0x0B, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x0A, 0xBF, 0xBF, 0x7F, 0x0B, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xC9, 0xCA, 0xBF, 0x7F, 0x0B, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xC7, 0x08, 0x09, 0xCA, 0x0B, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x7F, 0xBF, 0xBF, 0x7F, 0x0A, 0x0B, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xC9, 0xBF, 0xBF, 0x7F, 0x0A, 0x0B, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x08, 0x09, 0x7F, 0xBF, 0x0A, 0x0B, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x06, 0xC7, 0x08, 0xC9, 0x0A, 0x0B, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x7F, 0x7F, 0x7F, 0xBF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xC7, 0x7F, 0x7F, 0xBF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x06, 0xC7, 0x7F, 0xBF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F,
	0x04, 0x05, 0xC6, 0xC7, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F, 0x7F,
	0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0x0E, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0xCD, 0xCE, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0xCB, 0x0C, 0xCD, 0x0E, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0x7F, 0xBF, 0x7F, 0x7F, 0x0E, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0xCD, 0xBF, 0x7F, 0x7F, 0x0E, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0x0C, 0x0D, 0xBF, 0x7F, 0x0E, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0x0A, 0xCB, 0xCC, 0x0D, 0x0E, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0xBF, 0xBF, 0x7F, 0x7F, 0x0D, 0x0E, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0x0C, 0x7F, 0xBF, 0x7F, 0x0D, 0x0E, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0xCB, 0x0C, 0xBF, 0x7F, 0x0D, 0x0E, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0xC9, 0xCA, 0xCB, 0x0C, 0x0D, 0x0E, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0xBF, 0x7F, 0xBF, 0x7F, 0x0B, 0x0C, 0x0D, 0x0E, 0x7F, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0x0A, 0xBF, 0xBF, 0x7F, 0x0B, 0x0C, 0x0D, 0x0E, 0x7F, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0xC9, 0xCA, 0xBF, 0x7F, 0x0B, 0x0C, 0x0D, 0x0E, 0x7F, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0xC7, 0x08, 0x09, 0xCA, 0x0B, 0x0C, 0x0D, 0x0E, 0x7F, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0x7F, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0E, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0xCD, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0E, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0x0C, 0x0D, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0E, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0x0A, 0xCB, 0xCC, 0x0D, 0x7F, 0x7F, 0x7F, 0x7F, 0x0E, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0xBF, 0xBF, 0x7F, 0x7F, 0x0D, 0x7F, 0x7F, 0x7F, 0x0E, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0x0C, 0x7F, 0xBF, 0x7F, 0x0D, 0x7F, 0x7F, 0x7F, 0x0E, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0xCB, 0x0C, 0xBF, 0x7F, 0x0D, 0x7F, 0x7F, 0x7F, 0x0E, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0xC9, 0xCA, 0xCB, 0x0C, 0x0D, 0x7F, 0x7F, 0x7F, 0x0E, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0x7F, 0x7F, 0xBF, 0x7F, 0x0C, 0x0D, 0x7F, 0x7F, 0x0E, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0xCB, 0x7F, 0xBF, 0x7F, 0x0C, 0x0D, 0x7F, 0x7F, 0x0E, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0x0A, 0xCB, 0xBF, 0x7F, 0x0C, 0x0D, 0x7F, 0x7F, 0x0E, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0x08, 0x09, 0x0A, 0xCB, 0x0C, 0x0D, 0x7F, 0x7F, 0x0E, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0x7F, 0xBF, 0xBF, 0x7F, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0xC9, 0xBF, 0xBF, 0x7F, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0x08, 0x09, 0x7F, 0xBF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0x06, 0xC7, 0x08, 0xC9, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x7F, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0xBF, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0D, 0x0E, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0x0C, 0x7F, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0D, 0x0E, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0xCB, 0x0C, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0D, 0x0E, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0xC9, 0xCA, 0xCB, 0x0C, 0x7F, 0x7F, 0x7F, 0x7F, 0x0D, 0x0E, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0x7F, 0x7F, 0xBF, 0x7F, 0x0C, 0x7F, 0x7F, 0x7F, 0x0D, 0x0E, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0xCB, 0x7F, 0xBF, 0x7F, 0x0C, 0x7F, 0x7F, 0x7F, 0x0D, 0x0E, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0x0A, 0xCB, 0xBF, 0x7F, 0x0C, 0x7F, 0x7F, 0x7F, 0x0D, 0x0E, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0x08, 0x09, 0x0A, 0xCB, 0x0C, 0x7F, 0x7F, 0x7F, 0x0D, 0x0E, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0xBF, 0x7F, 0xBF, 0x7F, 0x0B, 0x0C, 0x7F, 0x7F, 0x0D, 0x0E, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0x0A, 0xBF, 0xBF, 0x7F, 0x0B, 0x0C, 0x7F, 0x7F, 0x0D, 0x0E, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0xC9, 0xCA, 0xBF, 0x7F, 0x0B, 0x0C, 0x7F, 0x7F, 0x0D, 0x0E, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0xC7, 0x08, 0x09, 0xCA, 0x0B, 0x0C, 0x7F, 0x7F, 0x0D, 0x0E, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0xBF, 0xBF, 0xBF, 0x7F, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0x08, 0x7F, 0x7F, 0xBF, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0xC7, 0x08, 0x7F, 0xBF, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0xC5, 0xC6, 0x07, 0xC8, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x7F, 0x7F, 0x0F, 0x7F, 0x7F, 0x7F,
	0xBF, 0x7F, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F,
	0x0A, 0xBF, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F,
	0xC9, 0xCA, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F,
	0xC7, 0x08, 0x09, 0xCA, 0x7F, 0x7F, 0x7F, 0x7F, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F,
	0x7F, 0xBF, 0xBF, 0x7F, 0x0A, 0x7F, 0x7F, 0x7F, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F,
	0xC9, 0xBF, 0xBF, 0x7F, 0x0A, 0x7F, 0x7F, 0x7F, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F,
	0x08, 0x09, 0x7F, 0xBF, 0x0A, 0x7F, 0x7F, 0x7F, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F,
	0x06, 0xC7, 0x08, 0xC9, 0x0A, 0x7F, 0x7F, 0x7F, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F,
	0xBF, 0xBF, 0xBF, 0x7F, 0x09, 0x0A, 0x7F, 0x7F, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F,
	0x08, 0x7F, 0x7F, 0xBF, 0x09, 0x0A, 0x7F, 0x7F, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F,
	0xC7, 0x08, 0x7F, 0xBF, 0x09, 0x0A, 0x7F, 0x7F, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F,
	0xC5, 0xC6, 0x07, 0xC8, 0x09, 0x0A, 0x7F, 0x7F, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F,
	0xBF, 0x7F, 0x7F, 0xBF, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F,
	0x06, 0xBF, 0x7F, 0xBF, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F,
	0xC5, 0xC6, 0x7F, 0xBF, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F,
	0xC3, 0x04, 0xC5, 0xC6, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F, 0x7F,
	0x7F, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0xCD, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0x0C, 0x0D, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0x0A, 0xCB, 0xCC, 0x0D, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0xBF, 0xBF, 0x7F, 0x7F, 0x0D, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0x0C, 0x7F, 0xBF, 0x7F, 0x0D, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0xCB, 0x0C, 0xBF, 0x7F, 0x0D, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0xC9, 0xCA, 0xCB, 0x0C, 0x0D, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0x7F, 0x7F, 0xBF, 0x7F, 0x0C, 0x0D, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0xCB, 0x7F, 0xBF, 0x7F, 0x0C, 0x0D, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0x0A, 0xCB, 0xBF, 0x7F, 0x0C, 0x0D, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0x08, 0x09, 0x0A, 0xCB, 0x0C, 0x0D, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0x7F, 0xBF, 0xBF, 0x7F, 0x0A, 0x0B, 0x0C, 0x0D, 0x7F, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0xC9, 0xBF, 0xBF, 0x7F, 0x0A, 0x0B, 0x0C, 0x0D, 0x7F, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0x08, 0x09, 0x7F, 0xBF, 0x0A, 0x0B, 0x0C, 0x0D, 0x7F, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0x06, 0xC7, 0x08, 0xC9, 0x0A, 0x0B, 0x0C, 0x0D, 0x7F, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0xBF, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0D, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0x0C, 0x7F, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0D, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0xCB, 0x0C, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0D, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0xC9, 0xCA, 0xCB, 0x0C, 0x7F, 0x7F, 0x7F, 0x7F, 0x0D, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0x7F, 0x7F, 0xBF, 0x7F, 0x0C, 0x7F, 0x7F, 0x7F, 0x0D, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0xCB, 0x7F, 0xBF, 0x7F, 0x0C, 0x7F, 0x7F, 0x7F, 0x0D, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0x0A, 0xCB, 0xBF, 0x7F, 0x0C, 0x7F, 0x7F, 0x7F, 0x0D, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0x08, 0x09, 0x0A, 0xCB, 0x0C, 0x7F, 0x7F, 0x7F, 0x0D, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0xBF, 0x7F, 0xBF, 0x7F, 0x0B, 0x0C, 0x7F, 0x7F, 0x0D, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0x0A, 0xBF, 0xBF, 0x7F, 0x0B, 0x0C, 0x7F, 0x7F, 0x0D, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0xC9, 0xCA, 0xBF, 0x7F, 0x0B, 0x0C, 0x7F, 0x7F, 0x0D, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0xC7, 0x08, 0x09, 0xCA, 0x0B, 0x0C, 0x7F, 0x7F, 0x0D, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0xBF, 0xBF, 0xBF, 0x7F, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0x08, 0x7F, 0x7F, 0xBF, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0xC7, 0x08, 0x7F, 0xBF, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0xC5, 0xC6, 0x07, 0xC8, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x7F, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0x7F, 0x7F, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0xCB, 0x7F, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0x0A, 0xCB, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0x08, 0x09, 0x0A, 0xCB, 0x7F, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0xBF, 0x7F, 0xBF, 0x7F, 0x0B, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0x0A, 0xBF, 0xBF, 0x7F, 0x0B, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0xC9, 0xCA, 0xBF, 0x7F, 0x0B, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0xC7, 0x08, 0x09, 0xCA, 0x0B, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0x7F, 0xBF, 0xBF, 0x7F, 0x0A, 0x0B, 0x7F, 0x7F, 0x0C, 0x0D, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0xC9, 0xBF, 0xBF, 0x7F, 0x0A, 0x0B, 0x7F, 0x7F, 0x0C, 0x0D, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0x08, 0x09, 0x7F, 0xBF, 0x0A, 0x0B, 0x7F, 0x7F, 0x0C, 0x0D, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0x06, 0xC7, 0x08, 0xC9, 0x0A, 0x0B, 0x7F, 0x7F, 0x0C, 0x0D, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0x7F, 0x7F, 0x7F, 0xBF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0xC7, 0x7F, 0x7F, 0xBF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0x06, 0xC7, 0x7F, 0xBF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0x04, 0x05, 0xC6, 0xC7, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x7F, 0x7F, 0x0E, 0x0F, 0x7F, 0x7F,
	0x7F, 0xBF, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F,
	0xC9, 0xBF, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F,
	0x08, 0x09, 0x7F, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F,
	0x06, 0xC7, 0x08, 0xC9, 0x7F, 0x7F, 0x7F, 0x7F, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F,
	0xBF, 0xBF, 0xBF, 0x7F, 0x09, 0x7F, 0x7F, 0x7F, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F,
	0x08, 0x7F, 0x7F, 0xBF, 0x09, 0x7F, 0x7F, 0x7F, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F,
	0xC7, 0x08, 0x7F, 0xBF, 0x09, 0x7F, 0x7F, 0x7F, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F,
	0xC5, 0xC6, 0x07, 0xC8, 0x09, 0x7F, 0x7F, 0x7F, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F,
	0x7F, 0x7F, 0x7F, 0xBF, 0x08, 0x09, 0x7F, 0x7F, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F,
	0xC7, 0x7F, 0x7F, 0xBF, 0x08, 0x09, 0x7F, 0x7F, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F,
	0x06, 0xC7, 0x7F, 0xBF, 0x08, 0x09, 0x7F, 0x7F, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F,
	0x04, 0x05, 0xC6, 0xC7, 0x08, 0x09, 0x7F, 0x7F, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F,
	0x7F, 0xBF, 0x7F, 0xBF, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F,
	0xC5, 0xBF, 0x7F, 0xBF, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F,
	0x04, 0x05, 0xBF, 0xBF, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F,
	0x02, 0xC3, 0xC4, 0xC5, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x7F, 0x7F,
	0x7F, 0x7F, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0xCB, 0x7F, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0x0A, 0xCB, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0x08, 0x09, 0x0A, 0xCB, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0xBF, 0x7F, 0xBF, 0x7F, 0x0B, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0x0A, 0xBF, 0xBF, 0x7F, 0x0B, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0xC9, 0xCA, 0xBF, 0x7F, 0x0B, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0xC7, 0x08, 0x09, 0xCA, 0x0B, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0x7F, 0xBF, 0xBF, 0x7F, 0x0A, 0x0B, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0xC9, 0xBF, 0xBF, 0x7F, 0x0A, 0x0B, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0x08, 0x09, 0x7F, 0xBF, 0x0A, 0x0B, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0x06, 0xC7, 0x08, 0xC9, 0x0A, 0x0B, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0x7F, 0x7F, 0x7F, 0xBF, 0x08, 0x09, 0x0A, 0x0B, 0x7F, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0xC7, 0x7F, 0x7F, 0xBF, 0x08, 0x09, 0x0A, 0x0B, 0x7F, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0x06, 0xC7, 0x7F, 0xBF, 0x08, 0x09, 0x0A, 0x0B, 0x7F, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0x04, 0x05, 0xC6, 0xC7, 0x08, 0x09, 0x0A, 0x0B, 0x7F, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0xBF, 0x7F, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0B, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0x0A, 0xBF, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0B, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0xC9, 0xCA, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0B, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0xC7, 0x08, 0x09, 0xCA, 0x7F, 0x7F, 0x7F, 0x7F, 0x0B, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0x7F, 0xBF, 0xBF, 0x7F, 0x0A, 0x7F, 0x7F, 0x7F, 0x0B, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0xC9, 0xBF, 0xBF, 0x7F, 0x0A, 0x7F, 0x7F, 0x7F, 0x0B, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0x08, 0x09, 0x7F, 0xBF, 0x0A, 0x7F, 0x7F, 0x7F, 0x0B, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0x06, 0xC7, 0x08, 0xC9, 0x0A, 0x7F, 0x7F, 0x7F, 0x0B, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0xBF, 0xBF, 0xBF, 0x7F, 0x09, 0x0A, 0x7F, 0x7F, 0x0B, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0x08, 0x7F, 0x7F, 0xBF, 0x09, 0x0A, 0x7F, 0x7F, 0x0B, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0xC7, 0x08, 0x7F, 0xBF, 0x09, 0x0A, 0x7F, 0x7F, 0x0B, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0xC5, 0xC6, 0x07, 0xC8, 0x09, 0x0A, 0x7F, 0x7F, 0x0B, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0xBF, 0x7F, 0x7F, 0xBF, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0x06, 0xBF, 0x7F, 0xBF, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0xC5, 0xC6, 0x7F, 0xBF, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0xC3, 0x04, 0xC5, 0xC6, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x7F, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0x7F, 0xBF, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0A, 0x0B, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0xC9, 0xBF, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x0A, 0x0B, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0x08, 0x09, 0x7F, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x0A, 0x0B, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0x06, 0xC7, 0x08, 0xC9, 0x7F, 0x7F, 0x7F, 0x7F, 0x0A, 0x0B, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0xBF, 0xBF, 0xBF, 0x7F, 0x09, 0x7F, 0x7F, 0x7F, 0x0A, 0x0B, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0x08, 0x7F, 0x7F, 0xBF, 0x09, 0x7F, 0x7F, 0x7F, 0x0A, 0x0B, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0xC7, 0x08, 0x7F, 0xBF, 0x09, 0x7F, 0x7F, 0x7F, 0x0A, 0x0B, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0xC5, 0xC6, 0x07, 0xC8, 0x09, 0x7F, 0x7F, 0x7F, 0x0A, 0x0B, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0x7F, 0x7F, 0x7F, 0xBF, 0x08, 0x09, 0x7F, 0x7F, 0x0A, 0x0B, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0xC7, 0x7F, 0x7F, 0xBF, 0x08, 0x09, 0x7F, 0x7F, 0x0A, 0x0B, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0x06, 0xC7, 0x7F, 0xBF, 0x08, 0x09, 0x7F, 0x7F, 0x0A, 0x0B, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0x04, 0x05, 0xC6, 0xC7, 0x08, 0x09, 0x7F, 0x7F, 0x0A, 0x0B, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0x7F, 0xBF, 0x7F, 0xBF, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0xC5, 0xBF, 0x7F, 0xBF, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0x04, 0x05, 0xBF, 0xBF, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0x02, 0xC3, 0xC4, 0xC5, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x7F, 0x7F, 0x0C, 0x0D, 0x0E, 0x0F,
	0x7F, 0x7F, 0x7F, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0xC7, 0x7F, 0x7F, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x06, 0xC7, 0x7F, 0xBF, 0x7F, 0x7F, 0x7F, 0x7F, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x04, 0x05, 0xC6, 0xC7, 0x7F, 0x7F, 0x7F, 0x7F, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0xBF, 0x7F, 0x7F, 0xBF, 0x07, 0x7F, 0x7F, 0x7F, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x06, 0xBF, 0x7F, 0xBF, 0x07, 0x7F, 0x7F, 0x7F, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0xC5, 0xC6, 0x7F, 0xBF, 0x07, 0x7F, 0x7F, 0x7F, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0xC3, 0x04, 0xC5, 0xC6, 0x07, 0x7F, 0x7F, 0x7F, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x7F, 0xBF, 0x7F, 0xBF, 0x06, 0x07, 0x7F, 0x7F, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0xC5, 0xBF, 0x7F, 0xBF, 0x06, 0x07, 0x7F, 0x7F, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x04, 0x05, 0xBF, 0xBF, 0x06, 0x07, 0x7F, 0x7F, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x02, 0xC3, 0xC4, 0xC5, 0x06, 0x07, 0x7F, 0x7F, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x7F, 0x7F, 0xBF, 0xBF, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0xC3, 0x7F, 0xBF, 0xBF, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x02, 0xC3, 0xBF, 0xBF, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x00, 0x01, 0x02, 0x03, 0xC4, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
};


/**
 * Decode a xmmword from a "0124 format" stream. Unroll helper.
 * @param [in,out] data_ptr current position in the stream's data block.
 * @param [out] data decoded xmmword.
 */
#define SVB0_DECODE4(r, shuffle_offset)\
do { \
	__m128i shuf = _mm_loadu_si128((__m128i*) \
		(((uint8_t*)svb0_dec_table) + (shuffle_offset))); \
	data_ptr += (uint32_t)_mm_movemask_epi8(shuf); \
	r = _mm_loadu_si128((__m128i*)data_ptr); \
	shuf = _mm_add_epi8(shuf, _mm_set1_epi8(0x40)); \
	r = _mm_shuffle_epi8(r, shuf); \
} while (0)


/**
 * Decode an uint32_t from the stream
 * @param [in] key 2-bit control code.
 * @param [in,out] data_ptr
 * @param [out] dw decoded uint32_t.
 */
#define SVB0_DECODE1(key, data_ptr, dw) \
do { \
	size_t len = (key); \
	len += ((len >> 1) & len); /* convert 3 to 4 */ \
	data_ptr += len; \
	uint64_t qw = svb_loadu_u32(data_ptr); \
	qw >>= (32 - (len * 8)); \
	dw = (uint32_t)qw; \
} while (0)


/**
 * Decode an uint32_t from the stream, without chunking.
 * Extra careful not to read memory outside of the stream.
 * @param [in] key 2-bit control code.
 * @param [in,out] data_ptr
 * @param [out] dw decoded uint32_t.
 */
#define SVB0_DECODE1_SAFE(key, data_ptr, dw) \
do { \
	size_t len = (key); \
	switch (len) { \
		case 3: \
			dw = svb_loadu_u32(data_ptr); \
			len++; \
			break; \
		case 2: \
			dw = svb_loadu_u16(data_ptr); \
			break; \
		case 1: \
			dw = data_ptr[0]; \
			break; \
		case 0: \
			dw = 0; \
			break; \
	} \
	data_ptr += len; \
} while (0)


const uint8_t* svb0_dec (const uint8_t *restrict in, size_t count,
	uint32_t *restrict out)
{
	uint32_t key_block_len = _svb_key_block_len(count);
	const uint8_t *restrict key_ptr = in;
	const uint8_t *restrict data_ptr = &in[key_block_len];

	if ((count & ~63) != 0) {
		data_ptr -= 16;
		const uint8_t *end = &key_ptr[(count & ~63) >> 2];
		do {
			__m128i r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,rA,rB,rC,rD,rE,rF;
			uint64_t keys0 = svb_loadu_u64(key_ptr);
			uint64_t keys1 = svb_loadu_u64(&key_ptr[8]);
			key_ptr += 16;

			SVB0_DECODE4(r0, (keys0 & 0xFF) << 4);
			_mm_storeu_si128((__m128i*)&out[0*4], r0);
			SVB0_DECODE4(r1, (keys0 & 0xFF00) >> 4);
			_mm_storeu_si128((__m128i*)&out[1*4], r1);
			SVB0_DECODE4(r2, (keys0 >> 12) & 0x0FF0);
			_mm_storeu_si128((__m128i*)&out[2*4], r2);
			SVB0_DECODE4(r3, (keys0 >> 20) & 0x0FF0);
			_mm_storeu_si128((__m128i*)&out[3*4], r3);
			SVB0_DECODE4(r4, (keys0 >> 28) & 0x0FF0);
			_mm_storeu_si128((__m128i*)&out[4*4], r4);
			SVB0_DECODE4(r5, (keys0 >> 36) & 0x0FF0);
			_mm_storeu_si128((__m128i*)&out[5*4], r5);
			SVB0_DECODE4(r6, (keys0 >> 44) & 0x0FF0);
			_mm_storeu_si128((__m128i*)&out[6*4], r6);
			SVB0_DECODE4(r7, (keys0 >> 52) & 0x0FF0);
			_mm_storeu_si128((__m128i*)&out[7*4], r7);

			SVB0_DECODE4(r8, (keys1 & 0xFF) << 4);
			_mm_storeu_si128((__m128i*)&out[8*4], r8);
			SVB0_DECODE4(r9, (keys1 & 0xFF00) >> 4);
			_mm_storeu_si128((__m128i*)&out[9*4], r9);
			SVB0_DECODE4(rA, (keys1 >> 12) & 0x0FF0);
			_mm_storeu_si128((__m128i*)&out[10*4], rA);
			SVB0_DECODE4(rB, (keys1 >> 20) & 0x0FF0);
			_mm_storeu_si128((__m128i*)&out[11*4], rB);
			SVB0_DECODE4(rC, (keys1 >> 28) & 0x0FF0);
			_mm_storeu_si128((__m128i*)&out[12*4], rC);
			SVB0_DECODE4(rD, (keys1 >> 36) & 0x0FF0);
			_mm_storeu_si128((__m128i*)&out[13*4], rD);
			SVB0_DECODE4(rE, (keys1 >> 44) & 0x0FF0);
			_mm_storeu_si128((__m128i*)&out[14*4], rE);
			SVB0_DECODE4(rF, (keys1 >> 52) & 0x0FF0);
			_mm_storeu_si128((__m128i*)&out[15*4], rF);

			out += 64;
		} while(key_ptr != end);

		count &= 63;
		if (count != 0) {
			for (;;) {
				__m128i data;
				SVB0_DECODE4(data, *key_ptr << 4);
				key_ptr++;
				if (count > 4){
					count -= 4;
					_mm_storeu_si128((__m128i*)out, data);
					out += 4;
				} else {
					out[0] = _mm_extract_epi32(data, 0);
					if (count >= 2) out[1] = _mm_extract_epi32(data, 1);
					if (count >= 3) out[2] = _mm_extract_epi32(data, 2);
					if (count > 3) out[3] = _mm_extract_epi32(data, 3);
					break;
				}
			}
		}
		data_ptr += 16;
	} else {
		if (key_block_len >= 4) { // 4 byte chunks
			data_ptr -= 4;
			size_t keys = 0;
			size_t i = 0;
			do {
				if ((i & 3) == 0) {
					keys = *key_ptr++;
				} else {
					keys >>= 2;
				}
				uint32_t dw;
				SVB0_DECODE1(keys & 3, data_ptr, dw);
				out[i] = dw;
			} while (++i < count);
			data_ptr += 4;
		} else { // no chunking
			size_t keys;
			memcpy(&keys, key_ptr, key_block_len);
			for (uint32_t i = 0; i < count; i++) {
				uint32_t dw;
				SVB0_DECODE1_SAFE(keys & 3, data_ptr, dw);
				out[i] = dw;
				keys >>= 2;
			}
		}
	}
	return data_ptr;
}


const uint8_t* svb0z_dec (const uint8_t *restrict in, size_t count,
	uint32_t *restrict out)
{
	uint32_t key_block_len = _svb_key_block_len(count);
	const uint8_t *restrict key_ptr = in;
	const uint8_t *restrict data_ptr = &in[key_block_len];

	if ((count & ~63) != 0) {
		data_ptr -= 16;
		const uint8_t *end = &key_ptr[(count & ~63) >> 2];
		do {
			__m128i r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,rA,rB,rC,rD,rE,rF;
			uint64_t keys0 = svb_loadu_u64(key_ptr);
			uint64_t keys1 = svb_loadu_u64(&key_ptr[8]);
			key_ptr += 16;

			SVB0_DECODE4(r0, (keys0 & 0xFF) << 4);
			r0 = _mm_zigzag_decode_epi32(r0);
			_mm_storeu_si128((__m128i*)&out[0*4], r0);
			SVB0_DECODE4(r1, (keys0 & 0xFF00) >> 4);
			r1 = _mm_zigzag_decode_epi32(r1);
			_mm_storeu_si128((__m128i*)&out[1*4], r1);
			SVB0_DECODE4(r2, (keys0 >> 12) & 0x0FF0);
			r2 = _mm_zigzag_decode_epi32(r2);
			_mm_storeu_si128((__m128i*)&out[2*4], r2);
			SVB0_DECODE4(r3, (keys0 >> 20) & 0x0FF0);
			r3 = _mm_zigzag_decode_epi32(r3);
			_mm_storeu_si128((__m128i*)&out[3*4], r3);
			SVB0_DECODE4(r4, (keys0 >> 28) & 0x0FF0);
			r4 = _mm_zigzag_decode_epi32(r4);
			_mm_storeu_si128((__m128i*)&out[4*4], r4);
			SVB0_DECODE4(r5, (keys0 >> 36) & 0x0FF0);
			r5 = _mm_zigzag_decode_epi32(r5);
			_mm_storeu_si128((__m128i*)&out[5*4], r5);
			SVB0_DECODE4(r6, (keys0 >> 44) & 0x0FF0);
			r6 = _mm_zigzag_decode_epi32(r6);
			_mm_storeu_si128((__m128i*)&out[6*4], r6);
			SVB0_DECODE4(r7, (keys0 >> 52) & 0x0FF0);
			r7 = _mm_zigzag_decode_epi32(r7);
			_mm_storeu_si128((__m128i*)&out[7*4], r7);

			SVB0_DECODE4(r8, (keys1 & 0xFF) << 4);
			r8 = _mm_zigzag_decode_epi32(r8);
			_mm_storeu_si128((__m128i*)&out[8*4], r8);
			SVB0_DECODE4(r9, (keys1 & 0xFF00) >> 4);
			r9 = _mm_zigzag_decode_epi32(r9);
			_mm_storeu_si128((__m128i*)&out[9*4], r9);
			SVB0_DECODE4(rA, (keys1 >> 12) & 0x0FF0);
			rA = _mm_zigzag_decode_epi32(rA);
			_mm_storeu_si128((__m128i*)&out[10*4], rA);
			SVB0_DECODE4(rB, (keys1 >> 20) & 0x0FF0);
			rB = _mm_zigzag_decode_epi32(rB);
			_mm_storeu_si128((__m128i*)&out[11*4], rB);
			SVB0_DECODE4(rC, (keys1 >> 28) & 0x0FF0);
			rC = _mm_zigzag_decode_epi32(rC);
			_mm_storeu_si128((__m128i*)&out[12*4], rC);
			SVB0_DECODE4(rD, (keys1 >> 36) & 0x0FF0);
			rD = _mm_zigzag_decode_epi32(rD);
			_mm_storeu_si128((__m128i*)&out[13*4], rD);
			SVB0_DECODE4(rE, (keys1 >> 44) & 0x0FF0);
			rE = _mm_zigzag_decode_epi32(rE);
			_mm_storeu_si128((__m128i*)&out[14*4], rE);
			SVB0_DECODE4(rF, (keys1 >> 52) & 0x0FF0);
			rF = _mm_zigzag_decode_epi32(rF);
			_mm_storeu_si128((__m128i*)&out[15*4], rF);

			out += 64;
		} while(key_ptr != end);

		count &= 63;
		if (count != 0) {
			for (;;) {
				__m128i data;
				SVB0_DECODE4(data, *key_ptr << 4);
				data = _mm_zigzag_decode_epi32(data);
				key_ptr++;
				if (count > 4){
					count -= 4;
					_mm_storeu_si128((__m128i*)out, data);
					out += 4;
				} else {
					out[0] = _mm_extract_epi32(data, 0);
					if (count >= 2) out[1] = _mm_extract_epi32(data, 1);
					if (count >= 3) out[2] = _mm_extract_epi32(data, 2);
					if (count > 3) out[3] = _mm_extract_epi32(data, 3);
					break;
				}
			}
		}
		data_ptr += 16;
	} else {
		if (key_block_len >= 4) { // 4 byte chunks
			data_ptr -= 4;
			size_t keys = 0;
			size_t i = 0;
			do {
				if ((i & 3) == 0) {
					keys = *key_ptr++;
				} else {
					keys >>= 2;
				}
				uint32_t dw;
				SVB0_DECODE1(keys & 3, data_ptr, dw);
				dw = _zigzag_decode_32(dw);
				out[i] = dw;
			} while (++i < count);
			data_ptr += 4;
		} else { // no chunking
			size_t keys;
			memcpy(&keys, key_ptr, key_block_len);
			for (uint32_t i = 0; i < count; i++) {
				uint32_t dw;
				SVB0_DECODE1_SAFE(keys & 3, data_ptr, dw);
				dw = _zigzag_decode_32(dw);
				out[i] = dw;
				keys >>= 2;
			}
		}
	}
	return data_ptr;
}


const uint8_t* svb0d_dec_x64 (const uint8_t *restrict in, size_t count,
	uint32_t *restrict out, uint32_t previous)
{
	uint32_t key_block_len = _svb_key_block_len(count);
	const uint8_t *restrict key_ptr = in;
	const uint8_t *restrict data_ptr = &in[key_block_len];

	if ((count & ~63) != 0) {
		const uint8_t *end = &key_ptr[(count & ~63) >> 2];
		__m128i prev = _mm_undefined_si128();
		prev = _mm_insert_epi32(prev, previous, 3);
		data_ptr -= 16;
		do {
			__m128i r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,rA,rB,rC,rD,rE,rF;
			uint64_t keys0 = svb_loadu_u64(key_ptr);
			uint64_t keys1 = svb_loadu_u64(&key_ptr[8]);
			key_ptr += 16;

			SVB0_DECODE4(r0, (keys0 & 0xFF) << 4);
			prev = _mm_delta_decode_epi32(r0, prev);
			_mm_storeu_si128((__m128i*)&out[0*4], prev);
			SVB0_DECODE4(r1, (keys0 & 0xFF00) >> 4);
			prev = _mm_delta_decode_epi32(r1, prev);
			_mm_storeu_si128((__m128i*)&out[1*4], prev);
			SVB0_DECODE4(r2, (keys0 >> 12) & 0x0FF0);
			prev = _mm_delta_decode_epi32(r2, prev);
			_mm_storeu_si128((__m128i*)&out[2*4], prev);
			SVB0_DECODE4(r3, (keys0 >> 20) & 0x0FF0);
			prev = _mm_delta_decode_epi32(r3, prev);
			_mm_storeu_si128((__m128i*)&out[3*4], prev);
			SVB0_DECODE4(r4, (keys0 >> 28) & 0x0FF0);
			prev = _mm_delta_decode_epi32(r4, prev);
			_mm_storeu_si128((__m128i*)&out[4*4], prev);
			SVB0_DECODE4(r5, (keys0 >> 36) & 0x0FF0);
			prev = _mm_delta_decode_epi32(r5, prev);
			_mm_storeu_si128((__m128i*)&out[5*4], prev);
			SVB0_DECODE4(r6, (keys0 >> 44) & 0x0FF0);
			prev = _mm_delta_decode_epi32(r6, prev);
			_mm_storeu_si128((__m128i*)&out[6*4], prev);
			SVB0_DECODE4(r7, (keys0 >> 52) & 0x0FF0);
			prev = _mm_delta_decode_epi32(r7, prev);
			_mm_storeu_si128((__m128i*)&out[7*4], prev);

			SVB0_DECODE4(r8, (keys1 & 0xFF) << 4);
			prev = _mm_delta_decode_epi32(r8, prev);
			_mm_storeu_si128((__m128i*)&out[8*4], prev);
			SVB0_DECODE4(r9, (keys1 & 0xFF00) >> 4);
			prev = _mm_delta_decode_epi32(r9, prev);
			_mm_storeu_si128((__m128i*)&out[9*4], prev);
			SVB0_DECODE4(rA, (keys1 >> 12) & 0x0FF0);
			prev = _mm_delta_decode_epi32(rA, prev);
			_mm_storeu_si128((__m128i*)&out[10*4], prev);
			SVB0_DECODE4(rB, (keys1 >> 20) & 0x0FF0);
			prev = _mm_delta_decode_epi32(rB, prev);
			_mm_storeu_si128((__m128i*)&out[11*4], prev);
			SVB0_DECODE4(rC, (keys1 >> 28) & 0x0FF0);
			prev = _mm_delta_decode_epi32(rC, prev);
			_mm_storeu_si128((__m128i*)&out[12*4], prev);
			SVB0_DECODE4(rD, (keys1 >> 36) & 0x0FF0);
			prev = _mm_delta_decode_epi32(rD, prev);
			_mm_storeu_si128((__m128i*)&out[13*4], prev);
			SVB0_DECODE4(rE, (keys1 >> 44) & 0x0FF0);
			prev = _mm_delta_decode_epi32(rE, prev);
			_mm_storeu_si128((__m128i*)&out[14*4], prev);
			SVB0_DECODE4(rF, (keys1 >> 52) & 0x0FF0);
			prev = _mm_delta_decode_epi32(rF, prev);
			_mm_storeu_si128((__m128i*)&out[15*4], prev);

			out += 16*4;
		} while(key_ptr != end);

		count &= 63;
		if (count != 0) {
			for (;;) {
				__m128i data;
				SVB0_DECODE4(data, *key_ptr << 4);
				prev = _mm_delta_decode_epi32(data, prev);
				key_ptr++;
				if (count > 4){
					count -= 4;
					_mm_storeu_si128((__m128i*)out, prev);
					out += 4;
				} else {
					out[0] = _mm_extract_epi32(prev, 0);
					if (count >= 2) out[1] = _mm_extract_epi32(prev, 1);
					if (count >= 3) out[2] = _mm_extract_epi32(prev, 2);
					if (count > 3) out[3] = _mm_extract_epi32(prev, 3);
					break;
				}
			}
		}
		data_ptr += 16;
	} else {
		if (key_block_len >= 4) { // 4 byte chunks
			data_ptr -= 4;
			size_t keys = 0;
			size_t i = 0;
			do {
				if ((i & 3) == 0) {
					keys = *key_ptr++;
				} else {
					keys >>= 2;
				}
				uint32_t dw;
				SVB0_DECODE1(keys & 3, data_ptr, dw);
				previous = _delta_decode_32(dw, previous);
				out[i] = previous;
			} while (++i < count);
			data_ptr += 4;
		} else { // no chunking
			size_t keys;
			memcpy(&keys, key_ptr, key_block_len);
			for (uint32_t i = 0; i < count; i++) {
				uint32_t dw;
				SVB0_DECODE1_SAFE(keys & 3, data_ptr, dw);
				previous = _delta_decode_32(dw, previous);
				out[i] = previous;
				keys >>= 2;
			}
		}
	}
	return data_ptr;
}


const uint8_t* svb0dz_dec_x64 (const uint8_t *restrict in,
	size_t count, uint32_t *restrict out, uint32_t previous)
{
	uint32_t key_block_len = _svb_key_block_len(count);
	const uint8_t *restrict key_ptr = in;
	const uint8_t *restrict data_ptr = &in[key_block_len];

	if ((count & ~63) != 0) {
		const uint8_t *end = &key_ptr[(count & ~63) >> 2];
		__m128i prev = _mm_undefined_si128();
		prev = _mm_insert_epi32(prev, previous, 3);
		data_ptr -= 16;
		do {
			__m128i r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,rA,rB,rC,rD,rE,rF;
			uint64_t keys0 = svb_loadu_u64(key_ptr);
			uint64_t keys1 = svb_loadu_u64(&key_ptr[8]);
			key_ptr += 16;

			SVB0_DECODE4(r0, (keys0 & 0xFF) << 4);
			prev = _mm_delta_zigzag_decode_epi32(r0, prev);
			_mm_storeu_si128((__m128i*)&out[0*4], prev);
			SVB0_DECODE4(r1, (keys0 & 0xFF00) >> 4);
			prev = _mm_delta_zigzag_decode_epi32(r1, prev);
			_mm_storeu_si128((__m128i*)&out[1*4], prev);
			SVB0_DECODE4(r2, (keys0 >> 12) & 0x0FF0);
			prev = _mm_delta_zigzag_decode_epi32(r2, prev);
			_mm_storeu_si128((__m128i*)&out[2*4], prev);
			SVB0_DECODE4(r3, (keys0 >> 20) & 0x0FF0);
			prev = _mm_delta_zigzag_decode_epi32(r3, prev);
			_mm_storeu_si128((__m128i*)&out[3*4], prev);
			SVB0_DECODE4(r4, (keys0 >> 28) & 0x0FF0);
			prev = _mm_delta_zigzag_decode_epi32(r4, prev);
			_mm_storeu_si128((__m128i*)&out[4*4], prev);
			SVB0_DECODE4(r5, (keys0 >> 36) & 0x0FF0);
			prev = _mm_delta_zigzag_decode_epi32(r5, prev);
			_mm_storeu_si128((__m128i*)&out[5*4], prev);
			SVB0_DECODE4(r6, (keys0 >> 44) & 0x0FF0);
			prev = _mm_delta_zigzag_decode_epi32(r6, prev);
			_mm_storeu_si128((__m128i*)&out[6*4], prev);
			SVB0_DECODE4(r7, (keys0 >> 52) & 0x0FF0);
			prev = _mm_delta_zigzag_decode_epi32(r7, prev);
			_mm_storeu_si128((__m128i*)&out[7*4], prev);

			SVB0_DECODE4(r8, (keys1 & 0xFF) << 4);
			prev = _mm_delta_zigzag_decode_epi32(r8, prev);
			_mm_storeu_si128((__m128i*)&out[8*4], prev);
			SVB0_DECODE4(r9, (keys1 & 0xFF00) >> 4);
			prev = _mm_delta_zigzag_decode_epi32(r9, prev);
			_mm_storeu_si128((__m128i*)&out[9*4], prev);
			SVB0_DECODE4(rA, (keys1 >> 12) & 0x0FF0);
			prev = _mm_delta_zigzag_decode_epi32(rA, prev);
			_mm_storeu_si128((__m128i*)&out[10*4], prev);
			SVB0_DECODE4(rB, (keys1 >> 20) & 0x0FF0);
			prev = _mm_delta_zigzag_decode_epi32(rB, prev);
			_mm_storeu_si128((__m128i*)&out[11*4], prev);
			SVB0_DECODE4(rC, (keys1 >> 28) & 0x0FF0);
			prev = _mm_delta_zigzag_decode_epi32(rC, prev);
			_mm_storeu_si128((__m128i*)&out[12*4], prev);
			SVB0_DECODE4(rD, (keys1 >> 36) & 0x0FF0);
			prev = _mm_delta_zigzag_decode_epi32(rD, prev);
			_mm_storeu_si128((__m128i*)&out[13*4], prev);
			SVB0_DECODE4(rE, (keys1 >> 44) & 0x0FF0);
			prev = _mm_delta_zigzag_decode_epi32(rE, prev);
			_mm_storeu_si128((__m128i*)&out[14*4], prev);
			SVB0_DECODE4(rF, (keys1 >> 52) & 0x0FF0);
			prev = _mm_delta_zigzag_decode_epi32(rF, prev);
			_mm_storeu_si128((__m128i*)&out[15*4], prev);

			out += 16*4;
		} while(key_ptr != end);

		count &= 63;
		if (count != 0) {
			for (;;) {
				__m128i data;
				SVB0_DECODE4(data, *key_ptr << 4);
				prev = _mm_delta_zigzag_decode_epi32(data, prev);
				key_ptr++;
				if (count > 4){
					count -= 4;
					_mm_storeu_si128((__m128i*)out, prev);
					out += 4;
				} else {
					out[0] = _mm_extract_epi32(prev, 0);
					if (count >= 2) out[1] = _mm_extract_epi32(prev, 1);
					if (count >= 3) out[2] = _mm_extract_epi32(prev, 2);
					if (count > 3) out[3] = _mm_extract_epi32(prev, 3);
					break;
				}
			}
		}
		data_ptr += 16;
	} else {
		if (key_block_len >= 4) { // 4 byte chunks
			data_ptr -= 4;
			size_t keys = 0;
			size_t i = 0;
			do {
				if ((i & 3) == 0) {
					keys = *key_ptr++;
				} else {
					keys >>= 2;
				}
				uint32_t dw;
				SVB0_DECODE1(keys & 3, data_ptr, dw);
				previous = _delta_zigzag_decode_32(dw, previous);
				out[i] = previous;
			} while (++i < count);
			data_ptr += 4;
		} else { // no chunking
			size_t keys;
			memcpy(&keys, key_ptr, key_block_len);
			for (uint32_t i = 0; i < count; i++) {
				uint32_t dw;
				SVB0_DECODE1_SAFE(keys & 3, data_ptr, dw);
				previous = _delta_zigzag_decode_32(dw, previous);
				out[i] = previous;
				keys >>= 2;
			}
		}
	}
	return data_ptr;
}


/**
 * Decompress, transpose, and delta decode a "0124 format" stream.
 *
 * @param [in] in stream.
 * @param [in] count total number of elements in the stream.
 * @param [out] out array that is at least `(count * 4)` bytes in size.
 * @param [in] previous value to add to the first delta. It should be
 * the same value that was passed as `previous` to `svb0dt_enc()`.
 * @returns pointer to just past-the-end of the `in` stream.
 */
const uint8_t* svb0dt_dec_x64 (const uint8_t *restrict in,
	size_t count, uint32_t *restrict out, uint32_t previous)
{
	uint32_t key_block_len = _svb_key_block_len(count);
	const uint8_t *restrict key_ptr = in;
	const uint8_t *restrict data_ptr = &in[key_block_len];

	if ((count & ~63) != 0) {
		const uint8_t *end = &key_ptr[(count & ~63) >> 2];
		__m128i prev = _mm_undefined_si128();
		prev = _mm_insert_epi32(prev, previous, 3);
		data_ptr -= 16;
		do {
			__m128i r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,rA,rB,rC,rD,rE,rF;
			uint64_t keys0 = svb_loadu_u64(key_ptr);
			uint64_t keys1 = svb_loadu_u64(&key_ptr[8]);
			key_ptr += 16;
			prev = _mm_srli_si128(prev, 12);

			// Decode & sum the columns then transpose them into rows.
			SVB0_DECODE4(r0, (keys0 & 0xFF) << 4);
			SVB0_DECODE4(r1, (keys0 & 0xFF00) >> 4);
			SVB0_DECODE4(r2, (keys0 >> 12) & 0x0FF0);
			SVB0_DECODE4(r3, (keys0 >> 20) & 0x0FF0);
			r0 = _mm_add_epi32(r0, prev);
			r1 = _mm_add_epi32(r1, r0);
			r2 = _mm_add_epi32(r2, r1);
			r3 = _mm_add_epi32(r3, r2);
			prev = r3;
			SVB_TRANSPOSE(r0, r1, r2, r3);
			_mm_storeu_si128((__m128i*)&out[0], r0); // row is done

			SVB0_DECODE4(r4, (keys0 >> 28) & 0x0FF0);
			SVB0_DECODE4(r5, (keys0 >> 36) & 0x0FF0);
			SVB0_DECODE4(r6, (keys0 >> 44) & 0x0FF0);
			SVB0_DECODE4(r7, (keys0 >> 52) & 0x0FF0);
			r4 = _mm_add_epi32(r4, prev);
			r5 = _mm_add_epi32(r5, r4);
			r6 = _mm_add_epi32(r6, r5);
			r7 = _mm_add_epi32(r7, r6);
			prev = r7;
			SVB_TRANSPOSE(r4, r5, r6, r7);
			_mm_storeu_si128((__m128i*)&out[4], r4);

			SVB0_DECODE4(r8, (keys1 & 0xFF) << 4);
			SVB0_DECODE4(r9, (keys1 & 0xFF00) >> 4);
			SVB0_DECODE4(rA, (keys1 >> 12) & 0x0FF0);
			SVB0_DECODE4(rB, (keys1 >> 20) & 0x0FF0);
			r8 = _mm_add_epi32(r8, prev);
			r9 = _mm_add_epi32(r9, r8);
			rA = _mm_add_epi32(rA, r9);
			rB = _mm_add_epi32(rB, rA);
			prev = rB;
			SVB_TRANSPOSE(r8, r9, rA, rB);
			_mm_storeu_si128((__m128i*)&out[8], r8);

			SVB0_DECODE4(rC, (keys1 >> 28) & 0x0FF0);
			SVB0_DECODE4(rD, (keys1 >> 36) & 0x0FF0);
			SVB0_DECODE4(rE, (keys1 >> 44) & 0x0FF0);
			SVB0_DECODE4(rF, (keys1 >> 52) & 0x0FF0);
			rC = _mm_add_epi32(rC, prev);
			rD = _mm_add_epi32(rD, rC);
			rE = _mm_add_epi32(rE, rD);
			rF = _mm_add_epi32(rF, rE);
			prev = rF;
			SVB_TRANSPOSE(rC, rD, rE, rF);
			_mm_storeu_si128((__m128i*)&out[12], rC);

			// The first column is already done.
			// The other three columns (in row form) await the totals
			// from the previous columns to be added in.
			r0 = _mm_shuffle_epi32(prev, _MM_SHUFFLE(0,0,0,0));
			_mm_storeu_si128((__m128i*)&out[16], _mm_add_epi32(r1, r0));
			_mm_storeu_si128((__m128i*)&out[20], _mm_add_epi32(r5, r0));
			_mm_storeu_si128((__m128i*)&out[24], _mm_add_epi32(r9, r0));
			_mm_storeu_si128((__m128i*)&out[28], _mm_add_epi32(rD, r0));

			r4 = _mm_shuffle_epi32(prev, _MM_SHUFFLE(1, 1, 1, 1));
			r4 = _mm_add_epi32(r4, r0);
			_mm_storeu_si128((__m128i*)&out[32], _mm_add_epi32(r2, r4));
			_mm_storeu_si128((__m128i*)&out[36], _mm_add_epi32(r6, r4));
			_mm_storeu_si128((__m128i*)&out[40], _mm_add_epi32(rA, r4));
			_mm_storeu_si128((__m128i*)&out[44], _mm_add_epi32(rE, r4));

			r8 = _mm_shuffle_epi32(prev, _MM_SHUFFLE(2, 2, 2, 2));
			r8 = _mm_add_epi32(r8, r4);
			_mm_storeu_si128((__m128i*)&out[48], _mm_add_epi32(r3, r8));
			_mm_storeu_si128((__m128i*)&out[52], _mm_add_epi32(r7, r8));
			_mm_storeu_si128((__m128i*)&out[56], _mm_add_epi32(rB, r8));
			rF = _mm_add_epi32(rF, r8);
			_mm_storeu_si128((__m128i*)&out[60], rF);

			prev = rF;
			out += 4*16;
		} while(key_ptr != end);
		count &= 63; // chunks of 64 are done

		// do any remaining (no transpose)
		if (count != 0) {
			for (;;) {
				__m128i data;
				SVB0_DECODE4(data, *key_ptr << 4);
				key_ptr++;
				prev = _mm_delta_decode_epi32(data, prev);
				if (count > 4){
					count -= 4;
					_mm_storeu_si128((__m128i*)out, prev);
					out += 4;
				} else {
					out[0] = _mm_extract_epi32(prev, 0);
					if (count >= 2) out[1] = _mm_extract_epi32(prev, 1);
					if (count >= 3) out[2] = _mm_extract_epi32(prev, 2);
					if (count > 3) out[3] = _mm_extract_epi32(prev, 3);
					break;
				}
			}
		}
		data_ptr += 16;
	}
	else { // no transpose
		if (key_block_len >= 4) {
			data_ptr -= 4;
			size_t keys = 0;
			size_t i = 0;
			do {
				if ((i & 3) == 0) {
					keys = *key_ptr++;
				} else {
					keys >>= 2;
				}
				uint32_t dw;
				SVB0_DECODE1(keys & 3, data_ptr, dw);
				previous = _delta_decode_32(dw, previous);
				out[i] = previous;
			} while (++i < count);
			data_ptr += 4;
		} else { // no chunking
			size_t keys;
			memcpy(&keys, key_ptr, key_block_len);
			for (uint32_t i = 0; i < count; i++) {
				uint32_t dw;
				SVB0_DECODE1_SAFE(keys & 3, data_ptr, dw);
				previous = _delta_decode_32(dw, previous);
				out[i] = previous;
				keys >>= 2;
			}
		}
	}
	return data_ptr;
}

#else

static inline
uint32_t _svb0_decode1_generic (size_t *len, const uint8_t* src,
	size_t key)
{
	uint32_t r;
	switch (key){
		case 3:
			r = src[0];
			r |= src[1] << 8;
			r |= src[2] << 16;
			r |= src[3] << 24;
			*len = 4;
			break;
		case 2:
			r = src[0];
			r |= src[1] << 8;
			*len = 2;
			break;
		case 1:
			r = src[0];
			*len = 1;
			break;
		case 0:
			r = 0;
			*len = 0;
			break;
	}
	return r;
}


const uint8_t* svb0_dec_generic (const uint8_t *restrict in,
	size_t count, uint32_t *restrict out)
{
	uint32_t key_block_len = _svb_key_block_len(count);
	const uint8_t *restrict key_ptr = in;
	const uint8_t *restrict data_ptr = &in[key_block_len];

	size_t keys = 0;
	for (size_t i = 0; i < count; i++) {
		if ((i & 3) == 0) {
			keys = *key_ptr++;
		}
		size_t code = keys & 3;
		size_t len;
		keys >>= 2;
		out[i] = _svb0_decode1_generic(&len, data_ptr, code);
		data_ptr += len;
	}
	return data_ptr;
}


const uint8_t* svb0z_dec_generic (const uint8_t *restrict in,
	size_t count, uint32_t *restrict out)
{
	uint32_t key_block_len = _svb_key_block_len(count);
	const uint8_t *restrict key_ptr = in;
	const uint8_t *restrict data_ptr = &in[key_block_len];

	size_t keys = 0;
	for (size_t i = 0; i < count; i++) {
		if ((i & 3) == 0) {
			keys = *key_ptr++;
		}
		size_t code = keys & 3;
		size_t len;
		keys >>= 2;
		uint32_t dw = _svb0_decode1_generic(&len, data_ptr, code);
		out[i] = _zigzag_decode_32(dw);
		data_ptr += len;
	}
	return data_ptr;
}


const uint8_t* svb0d_dec_generic (const uint8_t *restrict in,
	size_t count, uint32_t *restrict out, uint32_t previous)
{
	uint32_t key_block_len = _svb_key_block_len(count);
	const uint8_t *restrict key_ptr = in;
	const uint8_t *restrict data_ptr = &in[key_block_len];

	size_t keys = 0;
	for (size_t i = 0; i < count; i++) {
		if ((i & 3) == 0) {
			keys = *key_ptr++;
		}
		size_t code = keys & 3;
		size_t len;
		keys >>= 2;
		uint32_t dw = _svb0_decode1_generic(&len, data_ptr, code);
		previous = _delta_decode_32(dw, previous);
		out[i] = previous;
		data_ptr += len;
	}
	return data_ptr;
}


const uint8_t* svb0dz_dec_generic (const uint8_t *restrict in,
	size_t count, uint32_t *restrict out, uint32_t previous)
{
	uint32_t key_block_len = _svb_key_block_len(count);
	const uint8_t *restrict key_ptr = in;
	const uint8_t *restrict data_ptr = &in[key_block_len];

	size_t keys = 0;
	for (size_t i = 0; i < count; i++) {
		if ((i & 3) == 0) {
			keys = *key_ptr++;
		}
		size_t code = keys & 3;
		size_t len;
		keys >>= 2;
		uint32_t dw = _svb0_decode1_generic(&len, data_ptr, code);
		previous = _delta_zigzag_decode_32(dw, previous);
		out[i] = previous;
		data_ptr += len;
	}
	return data_ptr;
}


const uint8_t* svb0dt_dec_generic (const uint8_t *restrict in,
	size_t count, uint32_t *restrict out, uint32_t previous)
{
	uint32_t key_block_len = _svb_key_block_len(count);
	const uint8_t *restrict key_ptr = in;
	const uint8_t *restrict data_ptr = &in[key_block_len];

	if ((count & ~63) != 0 ) {
		const uint8_t *end = &key_ptr[(count & ~63) >> 2];
		do {
			for (size_t i = 0; i < 16; i++) {
				size_t keys = key_ptr[i];
				for (size_t j = 0; j < 64; j += 16) {
					size_t k = keys & 3;
					size_t len;
					keys >>= 2;
					out[i+j] = _svb0_decode1_generic(&len, data_ptr, k);
					data_ptr += len;
				}
			}
			for (size_t i = 0; i < 64; i++) {
				previous = _delta_decode_32(out[i], previous);
				out[i] = previous;
			}
			key_ptr += 16;
			out += 64;
		} while (end != key_ptr);
		count &= 63;
	}

	size_t keys = 0;
	for (size_t i = 0; i < count; i++) {
		if ((i & 3) == 0) {
			keys = *key_ptr++;
		}
		size_t code = keys & 3;
		size_t len;
		keys >>= 2;
		uint32_t dw = _svb0_decode1_generic(&len, data_ptr, code);
		previous = _delta_decode_32(dw, previous);
		out[i] = previous;
		data_ptr += len;
	}
	return data_ptr;
}

#endif
