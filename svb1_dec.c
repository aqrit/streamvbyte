/**
 * @file svb1_dec.c
 * StreamVByte routines for decoding "1234 format" streams.
 *
 * x64 Note: we're continiously subtracting from data_ptr.
 * data_ptr may become invalid and point outside the buffer.
 * Which is undefined behavior in C (but should be okay on AMD64...)
 * An invalid memory location is never accessed.
 * This behavior allows `length` to be obtained from svb1_dec_table
 * instead of from svb1_len_table.
 */

#include <stddef.h> // size_t
#include <stdint.h> // uint8_t, uint16_t, uint32_t, uint64_t

#include "svb.h"
#include "svb_internal.h"

#if defined(__SSE4_1__) || defined(__AVX__)

#include <smmintrin.h> // SSE4.1 intrinsics

/// Decoder permutation table.
/// `__m128* shuf = (__m128i*)&svb1_dec_table[(key_byte*16)];
static const uint8_t svb1_dec_table[256*16] = {
	0x0C, 0xFF, 0xFF, 0xFF, 0x0D, 0xFF, 0xFF, 0xFF, 0x0E, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x0B, 0x0C, 0xFF, 0xFF, 0x0D, 0xFF, 0xFF, 0xFF, 0x0E, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0xFF, 0xFF, 0xFF, 0x0E, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0xFF, 0xFF, 0xFF, 0x0E, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0x0D, 0xFF, 0xFF, 0x0E, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0x0D, 0xFF, 0xFF, 0x0E, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0x0D, 0xFF, 0xFF, 0x0E, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0xFF, 0xFF, 0x0E, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x0A, 0xFF, 0xFF, 0xFF, 0x0B, 0x0C, 0x0D, 0xFF, 0x0E, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x09, 0x0A, 0xFF, 0xFF, 0x0B, 0x0C, 0x0D, 0xFF, 0x0E, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x08, 0x09, 0x0A, 0xFF, 0x0B, 0x0C, 0x0D, 0xFF, 0x0E, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0xFF, 0x0E, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x09, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x08, 0x09, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x07, 0x08, 0x09, 0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0xFF, 0xFF, 0xFF, 0x0D, 0x0E, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0xFF, 0xFF, 0xFF, 0x0D, 0x0E, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0xFF, 0xFF, 0xFF, 0x0D, 0x0E, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x08, 0x09, 0x0A, 0x0B, 0x0C, 0xFF, 0xFF, 0xFF, 0x0D, 0x0E, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x0A, 0xFF, 0xFF, 0xFF, 0x0B, 0x0C, 0xFF, 0xFF, 0x0D, 0x0E, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x09, 0x0A, 0xFF, 0xFF, 0x0B, 0x0C, 0xFF, 0xFF, 0x0D, 0x0E, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x08, 0x09, 0x0A, 0xFF, 0x0B, 0x0C, 0xFF, 0xFF, 0x0D, 0x0E, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0xFF, 0xFF, 0x0D, 0x0E, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x09, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0x0E, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x08, 0x09, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0x0E, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x07, 0x08, 0x09, 0xFF, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0x0E, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0x0E, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x08, 0xFF, 0xFF, 0xFF, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x07, 0x08, 0xFF, 0xFF, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x06, 0x07, 0x08, 0xFF, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x0A, 0xFF, 0xFF, 0xFF, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x09, 0x0A, 0xFF, 0xFF, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x08, 0x09, 0x0A, 0xFF, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x07, 0x08, 0x09, 0x0A, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x09, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x08, 0x09, 0xFF, 0xFF, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x07, 0x08, 0x09, 0xFF, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x08, 0xFF, 0xFF, 0xFF, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0x0D, 0x0E, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x07, 0x08, 0xFF, 0xFF, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0x0D, 0x0E, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x06, 0x07, 0x08, 0xFF, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0x0D, 0x0E, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0x0D, 0x0E, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x07, 0xFF, 0xFF, 0xFF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x06, 0x07, 0xFF, 0xFF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x05, 0x06, 0x07, 0xFF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF,
	0x09, 0xFF, 0xFF, 0xFF, 0x0A, 0xFF, 0xFF, 0xFF, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF, 0xFF,
	0x08, 0x09, 0xFF, 0xFF, 0x0A, 0xFF, 0xFF, 0xFF, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF, 0xFF,
	0x07, 0x08, 0x09, 0xFF, 0x0A, 0xFF, 0xFF, 0xFF, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF, 0xFF,
	0x06, 0x07, 0x08, 0x09, 0x0A, 0xFF, 0xFF, 0xFF, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF, 0xFF,
	0x08, 0xFF, 0xFF, 0xFF, 0x09, 0x0A, 0xFF, 0xFF, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF, 0xFF,
	0x07, 0x08, 0xFF, 0xFF, 0x09, 0x0A, 0xFF, 0xFF, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF, 0xFF,
	0x06, 0x07, 0x08, 0xFF, 0x09, 0x0A, 0xFF, 0xFF, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF, 0xFF,
	0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0xFF, 0xFF, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF, 0xFF,
	0x07, 0xFF, 0xFF, 0xFF, 0x08, 0x09, 0x0A, 0xFF, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF, 0xFF,
	0x06, 0x07, 0xFF, 0xFF, 0x08, 0x09, 0x0A, 0xFF, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF, 0xFF,
	0x05, 0x06, 0x07, 0xFF, 0x08, 0x09, 0x0A, 0xFF, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF, 0xFF,
	0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0xFF, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF, 0xFF,
	0x06, 0xFF, 0xFF, 0xFF, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF, 0xFF,
	0x05, 0x06, 0xFF, 0xFF, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF, 0xFF,
	0x04, 0x05, 0x06, 0xFF, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF, 0xFF,
	0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF, 0xFF,
	0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0xFF, 0xFF, 0xFF, 0x0D, 0xFF, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0xFF, 0xFF, 0xFF, 0x0D, 0xFF, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0xFF, 0xFF, 0xFF, 0x0D, 0xFF, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x08, 0x09, 0x0A, 0x0B, 0x0C, 0xFF, 0xFF, 0xFF, 0x0D, 0xFF, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x0A, 0xFF, 0xFF, 0xFF, 0x0B, 0x0C, 0xFF, 0xFF, 0x0D, 0xFF, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x09, 0x0A, 0xFF, 0xFF, 0x0B, 0x0C, 0xFF, 0xFF, 0x0D, 0xFF, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x08, 0x09, 0x0A, 0xFF, 0x0B, 0x0C, 0xFF, 0xFF, 0x0D, 0xFF, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0xFF, 0xFF, 0x0D, 0xFF, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x09, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0xFF, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x08, 0x09, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0xFF, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x07, 0x08, 0x09, 0xFF, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0xFF, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0xFF, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x08, 0xFF, 0xFF, 0xFF, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0xFF, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x07, 0x08, 0xFF, 0xFF, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0xFF, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x06, 0x07, 0x08, 0xFF, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0xFF, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0xFF, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x0A, 0xFF, 0xFF, 0xFF, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0x0D, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x09, 0x0A, 0xFF, 0xFF, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0x0D, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x08, 0x09, 0x0A, 0xFF, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0x0D, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x07, 0x08, 0x09, 0x0A, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0x0D, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x09, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0x0D, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x08, 0x09, 0xFF, 0xFF, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0x0D, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x07, 0x08, 0x09, 0xFF, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0x0D, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0x0D, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x08, 0xFF, 0xFF, 0xFF, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0x0D, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x07, 0x08, 0xFF, 0xFF, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0x0D, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x06, 0x07, 0x08, 0xFF, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0x0D, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0x0D, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x07, 0xFF, 0xFF, 0xFF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x06, 0x07, 0xFF, 0xFF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x05, 0x06, 0x07, 0xFF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0xFF, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x09, 0xFF, 0xFF, 0xFF, 0x0A, 0xFF, 0xFF, 0xFF, 0x0B, 0x0C, 0x0D, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x08, 0x09, 0xFF, 0xFF, 0x0A, 0xFF, 0xFF, 0xFF, 0x0B, 0x0C, 0x0D, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x07, 0x08, 0x09, 0xFF, 0x0A, 0xFF, 0xFF, 0xFF, 0x0B, 0x0C, 0x0D, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x06, 0x07, 0x08, 0x09, 0x0A, 0xFF, 0xFF, 0xFF, 0x0B, 0x0C, 0x0D, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x08, 0xFF, 0xFF, 0xFF, 0x09, 0x0A, 0xFF, 0xFF, 0x0B, 0x0C, 0x0D, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x07, 0x08, 0xFF, 0xFF, 0x09, 0x0A, 0xFF, 0xFF, 0x0B, 0x0C, 0x0D, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x06, 0x07, 0x08, 0xFF, 0x09, 0x0A, 0xFF, 0xFF, 0x0B, 0x0C, 0x0D, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0xFF, 0xFF, 0x0B, 0x0C, 0x0D, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x07, 0xFF, 0xFF, 0xFF, 0x08, 0x09, 0x0A, 0xFF, 0x0B, 0x0C, 0x0D, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x06, 0x07, 0xFF, 0xFF, 0x08, 0x09, 0x0A, 0xFF, 0x0B, 0x0C, 0x0D, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x05, 0x06, 0x07, 0xFF, 0x08, 0x09, 0x0A, 0xFF, 0x0B, 0x0C, 0x0D, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0xFF, 0x0B, 0x0C, 0x0D, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x06, 0xFF, 0xFF, 0xFF, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x05, 0x06, 0xFF, 0xFF, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x04, 0x05, 0x06, 0xFF, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0xFF, 0x0E, 0x0F, 0xFF, 0xFF,
	0x08, 0xFF, 0xFF, 0xFF, 0x09, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF,
	0x07, 0x08, 0xFF, 0xFF, 0x09, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF,
	0x06, 0x07, 0x08, 0xFF, 0x09, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF,
	0x05, 0x06, 0x07, 0x08, 0x09, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF,
	0x07, 0xFF, 0xFF, 0xFF, 0x08, 0x09, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF,
	0x06, 0x07, 0xFF, 0xFF, 0x08, 0x09, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF,
	0x05, 0x06, 0x07, 0xFF, 0x08, 0x09, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF,
	0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF,
	0x06, 0xFF, 0xFF, 0xFF, 0x07, 0x08, 0x09, 0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF,
	0x05, 0x06, 0xFF, 0xFF, 0x07, 0x08, 0x09, 0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF,
	0x04, 0x05, 0x06, 0xFF, 0x07, 0x08, 0x09, 0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF,
	0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF,
	0x05, 0xFF, 0xFF, 0xFF, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF,
	0x04, 0x05, 0xFF, 0xFF, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF,
	0x03, 0x04, 0x05, 0xFF, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF,
	0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF,
	0x0A, 0xFF, 0xFF, 0xFF, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0xFF, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x09, 0x0A, 0xFF, 0xFF, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0xFF, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x08, 0x09, 0x0A, 0xFF, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0xFF, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x07, 0x08, 0x09, 0x0A, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0xFF, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x09, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0xFF, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x08, 0x09, 0xFF, 0xFF, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0xFF, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x07, 0x08, 0x09, 0xFF, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0xFF, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0xFF, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x08, 0xFF, 0xFF, 0xFF, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0xFF, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x07, 0x08, 0xFF, 0xFF, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0xFF, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x06, 0x07, 0x08, 0xFF, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0xFF, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0xFF, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x07, 0xFF, 0xFF, 0xFF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0xFF, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x06, 0x07, 0xFF, 0xFF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0xFF, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x05, 0x06, 0x07, 0xFF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0xFF, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0xFF, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x09, 0xFF, 0xFF, 0xFF, 0x0A, 0xFF, 0xFF, 0xFF, 0x0B, 0x0C, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x08, 0x09, 0xFF, 0xFF, 0x0A, 0xFF, 0xFF, 0xFF, 0x0B, 0x0C, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x07, 0x08, 0x09, 0xFF, 0x0A, 0xFF, 0xFF, 0xFF, 0x0B, 0x0C, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x06, 0x07, 0x08, 0x09, 0x0A, 0xFF, 0xFF, 0xFF, 0x0B, 0x0C, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x08, 0xFF, 0xFF, 0xFF, 0x09, 0x0A, 0xFF, 0xFF, 0x0B, 0x0C, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x07, 0x08, 0xFF, 0xFF, 0x09, 0x0A, 0xFF, 0xFF, 0x0B, 0x0C, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x06, 0x07, 0x08, 0xFF, 0x09, 0x0A, 0xFF, 0xFF, 0x0B, 0x0C, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0xFF, 0xFF, 0x0B, 0x0C, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x07, 0xFF, 0xFF, 0xFF, 0x08, 0x09, 0x0A, 0xFF, 0x0B, 0x0C, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x06, 0x07, 0xFF, 0xFF, 0x08, 0x09, 0x0A, 0xFF, 0x0B, 0x0C, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x05, 0x06, 0x07, 0xFF, 0x08, 0x09, 0x0A, 0xFF, 0x0B, 0x0C, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0xFF, 0x0B, 0x0C, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x06, 0xFF, 0xFF, 0xFF, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x05, 0x06, 0xFF, 0xFF, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x04, 0x05, 0x06, 0xFF, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0xFF, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x08, 0xFF, 0xFF, 0xFF, 0x09, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x07, 0x08, 0xFF, 0xFF, 0x09, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x06, 0x07, 0x08, 0xFF, 0x09, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x05, 0x06, 0x07, 0x08, 0x09, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x07, 0xFF, 0xFF, 0xFF, 0x08, 0x09, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x06, 0x07, 0xFF, 0xFF, 0x08, 0x09, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x05, 0x06, 0x07, 0xFF, 0x08, 0x09, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x06, 0xFF, 0xFF, 0xFF, 0x07, 0x08, 0x09, 0xFF, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x05, 0x06, 0xFF, 0xFF, 0x07, 0x08, 0x09, 0xFF, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x04, 0x05, 0x06, 0xFF, 0x07, 0x08, 0x09, 0xFF, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xFF, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x05, 0xFF, 0xFF, 0xFF, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x04, 0x05, 0xFF, 0xFF, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x03, 0x04, 0x05, 0xFF, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0xFF, 0x0D, 0x0E, 0x0F, 0xFF,
	0x07, 0xFF, 0xFF, 0xFF, 0x08, 0xFF, 0xFF, 0xFF, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF,
	0x06, 0x07, 0xFF, 0xFF, 0x08, 0xFF, 0xFF, 0xFF, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF,
	0x05, 0x06, 0x07, 0xFF, 0x08, 0xFF, 0xFF, 0xFF, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF,
	0x04, 0x05, 0x06, 0x07, 0x08, 0xFF, 0xFF, 0xFF, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF,
	0x06, 0xFF, 0xFF, 0xFF, 0x07, 0x08, 0xFF, 0xFF, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF,
	0x05, 0x06, 0xFF, 0xFF, 0x07, 0x08, 0xFF, 0xFF, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF,
	0x04, 0x05, 0x06, 0xFF, 0x07, 0x08, 0xFF, 0xFF, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF,
	0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0xFF, 0xFF, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF,
	0x05, 0xFF, 0xFF, 0xFF, 0x06, 0x07, 0x08, 0xFF, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF,
	0x04, 0x05, 0xFF, 0xFF, 0x06, 0x07, 0x08, 0xFF, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF,
	0x03, 0x04, 0x05, 0xFF, 0x06, 0x07, 0x08, 0xFF, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF,
	0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0xFF, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF,
	0x04, 0xFF, 0xFF, 0xFF, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF,
	0x03, 0x04, 0xFF, 0xFF, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF,
	0x02, 0x03, 0x04, 0xFF, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF,
	0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF,
	0x09, 0xFF, 0xFF, 0xFF, 0x0A, 0xFF, 0xFF, 0xFF, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x08, 0x09, 0xFF, 0xFF, 0x0A, 0xFF, 0xFF, 0xFF, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x07, 0x08, 0x09, 0xFF, 0x0A, 0xFF, 0xFF, 0xFF, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x06, 0x07, 0x08, 0x09, 0x0A, 0xFF, 0xFF, 0xFF, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x08, 0xFF, 0xFF, 0xFF, 0x09, 0x0A, 0xFF, 0xFF, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x07, 0x08, 0xFF, 0xFF, 0x09, 0x0A, 0xFF, 0xFF, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x06, 0x07, 0x08, 0xFF, 0x09, 0x0A, 0xFF, 0xFF, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0xFF, 0xFF, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x07, 0xFF, 0xFF, 0xFF, 0x08, 0x09, 0x0A, 0xFF, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x06, 0x07, 0xFF, 0xFF, 0x08, 0x09, 0x0A, 0xFF, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x05, 0x06, 0x07, 0xFF, 0x08, 0x09, 0x0A, 0xFF, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0xFF, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x06, 0xFF, 0xFF, 0xFF, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x05, 0x06, 0xFF, 0xFF, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x04, 0x05, 0x06, 0xFF, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0xFF, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x08, 0xFF, 0xFF, 0xFF, 0x09, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x07, 0x08, 0xFF, 0xFF, 0x09, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x06, 0x07, 0x08, 0xFF, 0x09, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x05, 0x06, 0x07, 0x08, 0x09, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x07, 0xFF, 0xFF, 0xFF, 0x08, 0x09, 0xFF, 0xFF, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x06, 0x07, 0xFF, 0xFF, 0x08, 0x09, 0xFF, 0xFF, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x05, 0x06, 0x07, 0xFF, 0x08, 0x09, 0xFF, 0xFF, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xFF, 0xFF, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x06, 0xFF, 0xFF, 0xFF, 0x07, 0x08, 0x09, 0xFF, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x05, 0x06, 0xFF, 0xFF, 0x07, 0x08, 0x09, 0xFF, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x04, 0x05, 0x06, 0xFF, 0x07, 0x08, 0x09, 0xFF, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xFF, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x05, 0xFF, 0xFF, 0xFF, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x04, 0x05, 0xFF, 0xFF, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x03, 0x04, 0x05, 0xFF, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0xFF, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x07, 0xFF, 0xFF, 0xFF, 0x08, 0xFF, 0xFF, 0xFF, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x06, 0x07, 0xFF, 0xFF, 0x08, 0xFF, 0xFF, 0xFF, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x05, 0x06, 0x07, 0xFF, 0x08, 0xFF, 0xFF, 0xFF, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x04, 0x05, 0x06, 0x07, 0x08, 0xFF, 0xFF, 0xFF, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x06, 0xFF, 0xFF, 0xFF, 0x07, 0x08, 0xFF, 0xFF, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x05, 0x06, 0xFF, 0xFF, 0x07, 0x08, 0xFF, 0xFF, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x04, 0x05, 0x06, 0xFF, 0x07, 0x08, 0xFF, 0xFF, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0xFF, 0xFF, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x05, 0xFF, 0xFF, 0xFF, 0x06, 0x07, 0x08, 0xFF, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x04, 0x05, 0xFF, 0xFF, 0x06, 0x07, 0x08, 0xFF, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x03, 0x04, 0x05, 0xFF, 0x06, 0x07, 0x08, 0xFF, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0xFF, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x04, 0xFF, 0xFF, 0xFF, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x03, 0x04, 0xFF, 0xFF, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x02, 0x03, 0x04, 0xFF, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0xFF, 0x0C, 0x0D, 0x0E, 0x0F,
	0x06, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x05, 0x06, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x04, 0x05, 0x06, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x03, 0x04, 0x05, 0x06, 0x07, 0xFF, 0xFF, 0xFF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x05, 0xFF, 0xFF, 0xFF, 0x06, 0x07, 0xFF, 0xFF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x04, 0x05, 0xFF, 0xFF, 0x06, 0x07, 0xFF, 0xFF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x03, 0x04, 0x05, 0xFF, 0x06, 0x07, 0xFF, 0xFF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xFF, 0xFF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x04, 0xFF, 0xFF, 0xFF, 0x05, 0x06, 0x07, 0xFF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x03, 0x04, 0xFF, 0xFF, 0x05, 0x06, 0x07, 0xFF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x02, 0x03, 0x04, 0xFF, 0x05, 0x06, 0x07, 0xFF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xFF, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x03, 0xFF, 0xFF, 0xFF, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x02, 0x03, 0xFF, 0xFF, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x01, 0x02, 0x03, 0xFF, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
};


/**
 * Decode a xmmword from the stream.
 *
 * @param [out] data decoded xmmword.
 * @param [in] n unroll helper.
 * @param [in] offset `(key_byte * 16)`.
 */
#define SVB1_DECODE4(data, n, offset) \
do { \
	const uint8_t* p = &svb1_dec_table[(offset)]; \
	__m128i shuf = _mm_loadu_si128((__m128i*) p); \
	data_ptr -= *p; \
	data = _mm_loadu_si128((__m128i*) &data_ptr[n*16]); \
	data = _mm_shuffle_epi8(data, shuf); \
} while (0)


/**
 * Decode an uint32_t from the stream.
 *
 * @param [in] key 2-bit control code.
 * @param [in,out] data_ptr
 * @param [out] dw decoded uint32_t.
 */
#define SVB1_DECODE1(key, data_ptr, dw) \
do { \
	size_t len = (key) + 1; \
	data_ptr += len; \
	dw = svb_loadu_u32(data_ptr); \
	dw >>= 32 - (len * 8); \
} while(0)


/**
 * Decode an uint32_t from the stream, without chunking.
 * Extra careful not to read memory outside of the stream.
 *
 * @param [in] key 2-bit control code.
 * @param [in,out] data_ptr
 * @param [out] dw decoded uint32_t.
 */
#define SVB1_DECODE1_SAFE(key, data_ptr, dw) \
do { \
	switch (key) { \
		case 3: \
			dw = svb_loadu_u32(data_ptr); \
			break; \
		case 2: \
			dw = svb_loadu_u32(data_ptr - 1); \
			dw >>= 8; \
			break; \
		case 1: \
			dw = svb_loadu_u16(data_ptr); \
			break; \
		case 0: \
			dw = data_ptr[0]; \
			break; \
	} \
	data_ptr += 1 + (key); \
} while (0)


 /**
 * Decompress a "1234 format" stream.
 *
 * @param [in] in stream.
 * @param [in] count total number of elements in the stream.
 * @param [out] out array that is at least `(count * 4)` bytes in size.
 * @returns pointer to just past-the-end of the `in` stream.
 */
const uint8_t* svb1_dec_x64 (const uint8_t *restrict in,
	size_t count, uint32_t *restrict out)
{
	// key block is followed by a variable length literal data block
	uint32_t key_block_len = _svb_key_block_len(count);
	const uint8_t *restrict key_ptr = in;
	const uint8_t *restrict data_ptr = &in[key_block_len];

	// decode 64 elements per loop iteration
	if ((count & ~63) != 0) {
		const uint8_t *end = &key_ptr[(count & ~63) >> 2];
		do {
			__m128i r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,rA,rB,rC,rD,rE,rF;
			uint64_t keys0 = svb_loadu_u64(key_ptr);

			SVB1_DECODE4(r0, 0, (keys0 & 0xFF) << 4);
			_mm_storeu_si128((__m128i*)&out[0*4], r0);
			SVB1_DECODE4(r1, 1, (keys0 & 0xFF00) >> 4);
			_mm_storeu_si128((__m128i*)&out[1*4], r1);
			SVB1_DECODE4(r2, 2, (keys0 >> 12) & 0x0FF0);
			_mm_storeu_si128((__m128i*)&out[2*4], r2);
			SVB1_DECODE4(r3, 3, (keys0 >> 20) & 0x0FF0);
			_mm_storeu_si128((__m128i*)&out[3*4], r3);
			SVB1_DECODE4(r4, 4, (keys0 >> 28) & 0x0FF0);
			_mm_storeu_si128((__m128i*)&out[4*4], r4);
			SVB1_DECODE4(r5, 5, (keys0 >> 36) & 0x0FF0);
			_mm_storeu_si128((__m128i*)&out[5*4], r5);
			SVB1_DECODE4(r6, 6, (keys0 >> 44) & 0x0FF0);
			_mm_storeu_si128((__m128i*)&out[6*4], r6);
			SVB1_DECODE4(r7, 7, (keys0 >> 52) & 0x0FF0);
			_mm_storeu_si128((__m128i*)&out[7*4], r7);

			uint64_t keys1 = svb_loadu_u64(&key_ptr[8]);
			key_ptr += 16;

			SVB1_DECODE4(r8, 8, (keys1 & 0xFF) << 4);
			_mm_storeu_si128((__m128i*)&out[8*4], r8);
			SVB1_DECODE4(r9, 9, (keys1 & 0xFF00) >> 4);
			_mm_storeu_si128((__m128i*)&out[9*4], r9);
			SVB1_DECODE4(rA, 10, (keys1 >> 12) & 0x0FF0);
			_mm_storeu_si128((__m128i*)&out[10*4], rA);
			SVB1_DECODE4(rB, 11, (keys1 >> 20) & 0x0FF0);
			_mm_storeu_si128((__m128i*)&out[11*4], rB);
			SVB1_DECODE4(rC, 12, (keys1 >> 28) & 0x0FF0);
			_mm_storeu_si128((__m128i*)&out[12*4], rC);
			SVB1_DECODE4(rD, 13, (keys1 >> 36) & 0x0FF0);
			_mm_storeu_si128((__m128i*)&out[13*4], rD);
			SVB1_DECODE4(rE, 14, (keys1 >> 44) & 0x0FF0);
			_mm_storeu_si128((__m128i*)&out[14*4], rE);
			SVB1_DECODE4(rF, 15, (keys1 >> 52) & 0x0FF0);
			_mm_storeu_si128((__m128i*)&out[15*4], rF);

			data_ptr += 16*16;
			out += 16*4;

		} while(key_ptr != end);

		// decode 4 elements per loop iteration
		for (uint32_t i = 0; i < ((count & 63) >> 2); i++) {
			__m128i data;
			size_t keys = *key_ptr++;
			SVB1_DECODE4(data, 0, keys << 4);
			data_ptr += 16;
			_mm_storeu_si128((__m128i*)out, data);
			out += 4;
		}
		count &= 3; // chunks of 4 are done
	}

	// scalar tail loop
	if (count != 0) {
		if (key_block_len >= 3) {
			data_ptr -= 4;
			size_t keys = 0;
			size_t i = 0;
			do {
				if ((i & 3) == 0) {
					keys = *key_ptr++;
				} else {
					keys >>= 2;
				}
				uint32_t dw;
				SVB1_DECODE1(keys & 3, data_ptr, dw);
				out[i] = dw;
			} while (++i < count);
			data_ptr += 4;
		} else {
			// no chunking
			size_t keys = svb_loadu_u16(key_ptr);
			for (uint32_t i = 0; i < count; i++) {
				uint32_t dw;
				SVB1_DECODE1_SAFE(keys & 3, data_ptr, dw);
				out[i] = dw;
				keys >>= 2;
			}
		}
	}
	return data_ptr;
}


const uint8_t* svb1z_dec_x64 (const uint8_t *restrict in,
	size_t count, uint32_t *restrict out)
{
	// key block is followed by a variable length literal data block
	uint32_t key_block_len = _svb_key_block_len(count);
	const uint8_t *restrict key_ptr = in;
	const uint8_t *restrict data_ptr = &in[key_block_len];

	// decode 64 elements per loop iteration
	if ((count & ~63) != 0) {
		const uint8_t *end = &key_ptr[(count & ~63) >> 2];
		do {
			__m128i r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,rA,rB,rC,rD,rE,rF;
			uint64_t keys0 = svb_loadu_u64(key_ptr);

			SVB1_DECODE4(r0, 0, (keys0 & 0xFF) << 4);
			r0 = _mm_zigzag_decode_epi32(r0);
			_mm_storeu_si128((__m128i*)&out[0*4], r0);
			SVB1_DECODE4(r1, 1, (keys0 & 0xFF00) >> 4);
			r1 = _mm_zigzag_decode_epi32(r1);
			_mm_storeu_si128((__m128i*)&out[1*4], r1);
			SVB1_DECODE4(r2, 2, (keys0 >> 12) & 0x0FF0);
			r2 = _mm_zigzag_decode_epi32(r2);
			_mm_storeu_si128((__m128i*)&out[2*4], r2);
			SVB1_DECODE4(r3, 3, (keys0 >> 20) & 0x0FF0);
			r3 = _mm_zigzag_decode_epi32(r3);
			_mm_storeu_si128((__m128i*)&out[3*4], r3);
			SVB1_DECODE4(r4, 4, (keys0 >> 28) & 0x0FF0);
			r4 = _mm_zigzag_decode_epi32(r4);
			_mm_storeu_si128((__m128i*)&out[4*4], r4);
			SVB1_DECODE4(r5, 5, (keys0 >> 36) & 0x0FF0);
			r5 = _mm_zigzag_decode_epi32(r5);
			_mm_storeu_si128((__m128i*)&out[5*4], r5);
			SVB1_DECODE4(r6, 6, (keys0 >> 44) & 0x0FF0);
			r6 = _mm_zigzag_decode_epi32(r6);
			_mm_storeu_si128((__m128i*)&out[6*4], r6);
			SVB1_DECODE4(r7, 7, (keys0 >> 52) & 0x0FF0);
			r7 = _mm_zigzag_decode_epi32(r7);
			_mm_storeu_si128((__m128i*)&out[7*4], r7);

			uint64_t keys1 = svb_loadu_u64(&key_ptr[8]);
			key_ptr += 16;

			SVB1_DECODE4(r8, 8, (keys1 & 0xFF) << 4);
			r8 = _mm_zigzag_decode_epi32(r8);
			_mm_storeu_si128((__m128i*)&out[8*4], r8);
			SVB1_DECODE4(r9, 9, (keys1 & 0xFF00) >> 4);
			r9 = _mm_zigzag_decode_epi32(r9);
			_mm_storeu_si128((__m128i*)&out[9*4], r9);
			SVB1_DECODE4(rA, 10, (keys1 >> 12) & 0x0FF0);
			rA = _mm_zigzag_decode_epi32(rA);
			_mm_storeu_si128((__m128i*)&out[10*4], rA);
			SVB1_DECODE4(rB, 11, (keys1 >> 20) & 0x0FF0);
			rB = _mm_zigzag_decode_epi32(rB);
			_mm_storeu_si128((__m128i*)&out[11*4], rB);
			SVB1_DECODE4(rC, 12, (keys1 >> 28) & 0x0FF0);
			rC = _mm_zigzag_decode_epi32(rC);
			_mm_storeu_si128((__m128i*)&out[12*4], rC);
			SVB1_DECODE4(rD, 13, (keys1 >> 36) & 0x0FF0);
			rD = _mm_zigzag_decode_epi32(rD);
			_mm_storeu_si128((__m128i*)&out[13*4], rD);
			SVB1_DECODE4(rE, 14, (keys1 >> 44) & 0x0FF0);
			rE = _mm_zigzag_decode_epi32(rE);
			_mm_storeu_si128((__m128i*)&out[14*4], rE);
			SVB1_DECODE4(rF, 15, (keys1 >> 52) & 0x0FF0);
			rF = _mm_zigzag_decode_epi32(rF);
			_mm_storeu_si128((__m128i*)&out[15*4], rF);

			data_ptr += 16*16;
			out += 16*4;

		} while(key_ptr != end);

		// decode 4 elements per loop iteration
		for (uint32_t i = 0; i < ((count & 63) >> 2); i++) {
			__m128i data;
			size_t keys = *key_ptr++;
			SVB1_DECODE4(data, 0, keys << 4);
			data_ptr += 16;
			data = _mm_zigzag_decode_epi32(data);
			_mm_storeu_si128((__m128i*)out, data);
			out += 4;
		}
		count &= 3; // chunks of 4 are done
	}

	// scalar tail loop
	if (count != 0) {
		if (key_block_len >= 3) {
			data_ptr -= 4;
			size_t keys = 0;
			size_t i = 0;
			do {
				if ((i & 3) == 0) {
					keys = *key_ptr++;
				} else {
					keys >>= 2;
				}
				uint32_t dw;
				SVB1_DECODE1(keys & 3, data_ptr, dw);
				dw = _zigzag_decode_32(dw);
				out[i] = dw;
			} while (++i < count);
			data_ptr += 4;
		} else {
			// no chunking
			size_t keys = svb_loadu_u16(key_ptr);
			for (uint32_t i = 0; i < count; i++) {
				uint32_t dw;
				SVB1_DECODE1_SAFE(keys & 3, data_ptr, dw);
				dw = _zigzag_decode_32(dw);
				out[i] = dw;
				keys >>= 2;
			}
		}
	}
	return data_ptr;
}


/**
 * Decompress and delta decode a "1234 format" stream.
 *
 * @param [in] in stream.
 * @param [in] count total number of elements in the stream.
 * @param [out] out array that is at least `(count * 4)` bytes in size.
 * @param [in] previous value to add to first delta. It should be
 * the same value that was passed as `previous to svb1d_enc()`.

 * @returns pointer to just past-the-end of the `in` stream.
 */
const uint8_t* svb1d_dec_x64 (const uint8_t *restrict in,
	size_t count, uint32_t *restrict out, uint32_t previous)
{
	// key block is followed by a variable length literal data block
	uint32_t key_block_len = _svb_key_block_len(count);
	const uint8_t *restrict key_ptr = in;
	const uint8_t *restrict data_ptr = &in[key_block_len];

	// decode 64 elements per loop iteration
	if ((count & ~63) != 0) {
		const uint8_t *end = &key_ptr[(count & ~63) >> 2];
		__m128i prev = _mm_undefined_si128();
		prev = _mm_insert_epi32(prev, previous, 3);
		do {
			__m128i r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,rA,rB,rC,rD,rE,rF;
			uint64_t keys0 = svb_loadu_u64(key_ptr);

			SVB1_DECODE4(r0, 0, (keys0 & 0xFF) << 4);
			prev = _mm_delta_decode_epi32(r0, prev);
			_mm_storeu_si128((__m128i*)&out[0*4], prev);
			SVB1_DECODE4(r1, 1, (keys0 & 0xFF00) >> 4);
			prev = _mm_delta_decode_epi32(r1, prev);
			_mm_storeu_si128((__m128i*)&out[1*4], prev);
			SVB1_DECODE4(r2, 2, (keys0 >> 12) & 0x0FF0);
			prev = _mm_delta_decode_epi32(r2, prev);
			_mm_storeu_si128((__m128i*)&out[2*4], prev);
			SVB1_DECODE4(r3, 3, (keys0 >> 20) & 0x0FF0);
			prev = _mm_delta_decode_epi32(r3, prev);
			_mm_storeu_si128((__m128i*)&out[3*4], prev);
			SVB1_DECODE4(r4, 4, (keys0 >> 28) & 0x0FF0);
			prev = _mm_delta_decode_epi32(r4, prev);
			_mm_storeu_si128((__m128i*)&out[4*4], prev);
			SVB1_DECODE4(r5, 5, (keys0 >> 36) & 0x0FF0);
			prev = _mm_delta_decode_epi32(r5, prev);
			_mm_storeu_si128((__m128i*)&out[5*4], prev);
			SVB1_DECODE4(r6, 6, (keys0 >> 44) & 0x0FF0);
			prev = _mm_delta_decode_epi32(r6, prev);
			_mm_storeu_si128((__m128i*)&out[6*4], prev);
			SVB1_DECODE4(r7, 7, (keys0 >> 52) & 0x0FF0);
			prev = _mm_delta_decode_epi32(r7, prev);
			_mm_storeu_si128((__m128i*)&out[7*4], prev);

			uint64_t keys1 = svb_loadu_u64(&key_ptr[8]);
			key_ptr += 16;

			SVB1_DECODE4(r8, 8, (keys1 & 0xFF) << 4);
			prev = _mm_delta_decode_epi32(r8, prev);
			_mm_storeu_si128((__m128i*)&out[8*4], prev);
			SVB1_DECODE4(r9, 9, (keys1 & 0xFF00) >> 4);
			prev = _mm_delta_decode_epi32(r9, prev);
			_mm_storeu_si128((__m128i*)&out[9*4], prev);
			SVB1_DECODE4(rA, 10, (keys1 >> 12) & 0x0FF0);
			prev = _mm_delta_decode_epi32(rA, prev);
			_mm_storeu_si128((__m128i*)&out[10*4], prev);
			SVB1_DECODE4(rB, 11, (keys1 >> 20) & 0x0FF0);
			prev = _mm_delta_decode_epi32(rB, prev);
			_mm_storeu_si128((__m128i*)&out[11*4], prev);
			SVB1_DECODE4(rC, 12, (keys1 >> 28) & 0x0FF0);
			prev = _mm_delta_decode_epi32(rC, prev);
			_mm_storeu_si128((__m128i*)&out[12*4], prev);
			SVB1_DECODE4(rD, 13, (keys1 >> 36) & 0x0FF0);
			prev = _mm_delta_decode_epi32(rD, prev);
			_mm_storeu_si128((__m128i*)&out[13*4], prev);
			SVB1_DECODE4(rE, 14, (keys1 >> 44) & 0x0FF0);
			prev = _mm_delta_decode_epi32(rE, prev);
			_mm_storeu_si128((__m128i*)&out[14*4], prev);
			SVB1_DECODE4(rF, 15, (keys1 >> 52) & 0x0FF0);
			prev = _mm_delta_decode_epi32(rF, prev);
			_mm_storeu_si128((__m128i*)&out[15*4], prev);

			data_ptr += 16*16;
			out += 16*4;

		} while(key_ptr != end);

		// decode 4 elements per loop iteration
		for (uint32_t i = 0; i < ((count & 63) >> 2); i++) {
			__m128i data;
			size_t keys = *key_ptr++;
			SVB1_DECODE4(data, 0, keys << 4);
			data_ptr += 16;
			prev = _mm_delta_decode_epi32(data, prev);
			_mm_storeu_si128((__m128i*)out, prev);
			out += 4;
		}

		// prepare for scalar tail loop
		previous = (uint32_t)_mm_extract_epi32(prev, 3);
		count &= 3; // chunks of 4 are done
	}

	// scalar tail loop
	if (count != 0) {
		if (key_block_len >= 3) {
			data_ptr -= 4;
			size_t keys = 0;
			size_t i = 0;
			do {
				if ((i & 3) == 0) {
					keys = *key_ptr++;
				} else {
					keys >>= 2;
				}
				uint32_t dw;
				SVB1_DECODE1(keys & 3, data_ptr, dw);
				previous = _delta_decode_32(dw, previous);
				out[i] = previous;
			} while (++i < count);
			data_ptr += 4;
		} else {
			// no chunking
			size_t keys = svb_loadu_u16(key_ptr);
			for (uint32_t i = 0; i < count; i++) {
				uint32_t dw;
				SVB1_DECODE1_SAFE(keys & 3, data_ptr, dw);
				previous = _delta_decode_32(dw, previous);
				out[i] = previous;
				keys >>= 2;
			}
		}
	}
	return data_ptr;
}


const uint8_t* svb1dz_dec_x64 (const uint8_t *restrict in,
	size_t count, uint32_t *restrict out, uint32_t previous)
{
	// key block is followed by a variable length literal data block
	uint32_t key_block_len = _svb_key_block_len(count);
	const uint8_t *restrict key_ptr = in;
	const uint8_t *restrict data_ptr = &in[key_block_len];

	// decode 64 elements per loop iteration
	if ((count & ~63) != 0) {
		const uint8_t *end = &key_ptr[(count & ~63) >> 2];
		__m128i prev = _mm_insert_epi32(_mm_undefined_si128(), previous, 3);
		do {
			__m128i r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,rA,rB,rC,rD,rE,rF;
			uint64_t keys0 = svb_loadu_u64(key_ptr);

			SVB1_DECODE4(r0, 0, (keys0 & 0xFF) << 4);
			prev = _mm_delta_zigzag_decode_epi32(r0, prev);
			_mm_storeu_si128((__m128i*)&out[0*4], prev);
			SVB1_DECODE4(r1, 1, (keys0 & 0xFF00) >> 4);
			prev = _mm_delta_zigzag_decode_epi32(r1, prev);
			_mm_storeu_si128((__m128i*)&out[1*4], prev);
			SVB1_DECODE4(r2, 2, (keys0 >> 12) & 0x0FF0);
			prev = _mm_delta_zigzag_decode_epi32(r2, prev);
			_mm_storeu_si128((__m128i*)&out[2*4], prev);
			SVB1_DECODE4(r3, 3, (keys0 >> 20) & 0x0FF0);
			prev = _mm_delta_zigzag_decode_epi32(r3, prev);
			_mm_storeu_si128((__m128i*)&out[3*4], prev);
			SVB1_DECODE4(r4, 4, (keys0 >> 28) & 0x0FF0);
			prev = _mm_delta_zigzag_decode_epi32(r4, prev);
			_mm_storeu_si128((__m128i*)&out[4*4], prev);
			SVB1_DECODE4(r5, 5, (keys0 >> 36) & 0x0FF0);
			prev = _mm_delta_zigzag_decode_epi32(r5, prev);
			_mm_storeu_si128((__m128i*)&out[5*4], prev);
			SVB1_DECODE4(r6, 6, (keys0 >> 44) & 0x0FF0);
			prev = _mm_delta_zigzag_decode_epi32(r6, prev);
			_mm_storeu_si128((__m128i*)&out[6*4], prev);
			SVB1_DECODE4(r7, 7, (keys0 >> 52) & 0x0FF0);
			prev = _mm_delta_zigzag_decode_epi32(r7, prev);
			_mm_storeu_si128((__m128i*)&out[7*4], prev);

			uint64_t keys1 = svb_loadu_u64(&key_ptr[8]);
			key_ptr += 16;

			SVB1_DECODE4(r8, 8, (keys1 & 0xFF) << 4);
			prev = _mm_delta_zigzag_decode_epi32(r8, prev);
			_mm_storeu_si128((__m128i*)&out[8*4], prev);
			SVB1_DECODE4(r9, 9, (keys1 & 0xFF00) >> 4);
			prev = _mm_delta_zigzag_decode_epi32(r9, prev);
			_mm_storeu_si128((__m128i*)&out[9*4], prev);
			SVB1_DECODE4(rA, 10, (keys1 >> 12) & 0x0FF0);
			prev = _mm_delta_zigzag_decode_epi32(rA, prev);
			_mm_storeu_si128((__m128i*)&out[10*4], prev);
			SVB1_DECODE4(rB, 11, (keys1 >> 20) & 0x0FF0);
			prev = _mm_delta_zigzag_decode_epi32(rB, prev);
			_mm_storeu_si128((__m128i*)&out[11*4], prev);
			SVB1_DECODE4(rC, 12, (keys1 >> 28) & 0x0FF0);
			prev = _mm_delta_zigzag_decode_epi32(rC, prev);
			_mm_storeu_si128((__m128i*)&out[12*4], prev);
			SVB1_DECODE4(rD, 13, (keys1 >> 36) & 0x0FF0);
			prev = _mm_delta_zigzag_decode_epi32(rD, prev);
			_mm_storeu_si128((__m128i*)&out[13*4], prev);
			SVB1_DECODE4(rE, 14, (keys1 >> 44) & 0x0FF0);
			prev = _mm_delta_zigzag_decode_epi32(rE, prev);
			_mm_storeu_si128((__m128i*)&out[14*4], prev);
			SVB1_DECODE4(rF, 15, (keys1 >> 52) & 0x0FF0);
			prev = _mm_delta_zigzag_decode_epi32(rF, prev);
			_mm_storeu_si128((__m128i*)&out[15*4], prev);

			data_ptr += 16*16;
			out += 16*4;

		} while(key_ptr != end);

		// decode 4 elements per loop iteration
		for (uint32_t i = 0; i < ((count & 63) >> 2); i++) {
			__m128i data;
			size_t keys = *key_ptr++;
			SVB1_DECODE4(data, 0, keys << 4);
			data_ptr += 16;
			prev = _mm_delta_zigzag_decode_epi32(data, prev);
			_mm_storeu_si128((__m128i*)out, prev);
			out += 4;
		}

		// prepare for scalar tail loop
		previous = (uint32_t)_mm_extract_epi32(prev, 3);
		count &= 3; // chunks of 4 are done
	}

	// scalar tail loop
	if (count != 0) {
		if (key_block_len >= 3) {
			data_ptr -= 4;
			size_t keys = 0;
			size_t i = 0;
			do {
				if ((i & 3) == 0) {
					keys = *key_ptr++;
				} else {
					keys >>= 2;
				}
				uint32_t dw;
				SVB1_DECODE1(keys & 3, data_ptr, dw);
				previous = _delta_zigzag_decode_32(dw, previous);
				out[i] = previous;
			} while (++i < count);
			data_ptr += 4;
		} else {
			// no chunking
			size_t keys = svb_loadu_u16(key_ptr);
			for (uint32_t i = 0; i < count; i++) {
				uint32_t dw;
				SVB1_DECODE1_SAFE(keys & 3, data_ptr, dw);
				previous = _delta_zigzag_decode_32(dw, previous);
				out[i] = previous;
				keys >>= 2;
			}
		}
	}
	return data_ptr;
}


/**
 * Decompress, transpose, and delta decode a "1234 format" stream.
 *
 * @param [in] in stream.
 * @param [in] count total number of elements in the stream.
 * @param [out] out array that is at least `(count * 4)` bytes in size.
 * @param [in] previous value to add to the first delta. It should be
 * the same value that was passed as `previous` to `svb1dt_enc()`.
 * @returns pointer to just past-the-end of the `in` stream.
 */
const uint8_t* svb1dt_dec_x64 (
	const uint8_t *restrict in,
	size_t count,
	uint32_t *restrict out,
	uint32_t previous)
{
	// key block is followed by a variable length literal data block
	uint32_t key_block_len = _svb_key_block_len(count);
	const uint8_t *restrict key_ptr = in;
	const uint8_t *restrict data_ptr = &in[key_block_len];

	// decode 64 elements per loop iteration
	if ((count & ~63) != 0) {
		const uint8_t *end = &key_ptr[(count & ~63) >> 2];
		__m128i prev = _mm_undefined_si128();
		prev = _mm_insert_epi32(prev, previous, 3);
		do {
			__m128i r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,rA,rB,rC,rD,rE,rF;

			uint64_t keys0 = svb_loadu_u64(key_ptr);
			prev = _mm_srli_si128(prev, 12);

			// Decode & sum the columns then transpose them into rows.
			SVB1_DECODE4(r0, 0, (keys0 & 0xFF) << 4);
			SVB1_DECODE4(r1, 1, (keys0 & 0xFF00) >> 4);
			SVB1_DECODE4(r2, 2, (keys0 >> 12) & 0x0FF0);
			SVB1_DECODE4(r3, 3, (keys0 >> 20) & 0x0FF0);
			r0 = _mm_add_epi32(r0, prev); // add carry to first column
			r1 = _mm_add_epi32(r1, r0);
			r2 = _mm_add_epi32(r2, r1);
			r3 = _mm_add_epi32(r3, r2);
			prev = r3;
			SVB_TRANSPOSE(r0, r1, r2, r3);
			_mm_storeu_si128((__m128i*)&out[0], r0); // row is done

			SVB1_DECODE4(r4, 4, (keys0 >> 28) & 0x0FF0);
			SVB1_DECODE4(r5, 5, (keys0 >> 36) & 0x0FF0);
			SVB1_DECODE4(r6, 6, (keys0 >> 44) & 0x0FF0);
			SVB1_DECODE4(r7, 7, (keys0 >> 52) & 0x0FF0);
			r4 = _mm_add_epi32(r4, prev);
			r5 = _mm_add_epi32(r5, r4);
			r6 = _mm_add_epi32(r6, r5);
			r7 = _mm_add_epi32(r7, r6);
			prev = r7;
			SVB_TRANSPOSE(r4, r5, r6, r7);
			_mm_storeu_si128((__m128i*)&out[4], r4);

			uint64_t keys1 = svb_loadu_u64(&key_ptr[8]);
			key_ptr += 16;

			SVB1_DECODE4(r8, 8, (keys1 & 0xFF) << 4);
			SVB1_DECODE4(r9, 9, (keys1 & 0xFF00) >> 4);
			SVB1_DECODE4(rA, 10, (keys1 >> 12) & 0x0FF0);
			SVB1_DECODE4(rB, 11, (keys1 >> 20) & 0x0FF0);
			r8 = _mm_add_epi32(r8, prev);
			r9 = _mm_add_epi32(r9, r8);
			rA = _mm_add_epi32(rA, r9);
			rB = _mm_add_epi32(rB, rA);
			prev = rB;
			SVB_TRANSPOSE(r8, r9, rA, rB);
			_mm_storeu_si128((__m128i*)&out[8], r8);

			SVB1_DECODE4(rC, 12, (keys1 >> 28) & 0x0FF0);
			SVB1_DECODE4(rD, 13, (keys1 >> 36) & 0x0FF0);
			SVB1_DECODE4(rE, 14, (keys1 >> 44) & 0x0FF0);
			SVB1_DECODE4(rF, 15, (keys1 >> 52) & 0x0FF0);
			rC = _mm_add_epi32(rC, prev);
			rD = _mm_add_epi32(rD, rC);
			rE = _mm_add_epi32(rE, rD);
			rF = _mm_add_epi32(rF, rE);
			prev = rF;
			SVB_TRANSPOSE(rC, rD, rE, rF);
			_mm_storeu_si128((__m128i*)&out[12], rC);

			// The first column is already done.
			// The other three columns (in row form) await the totals
			// from the previous columns to be added in.
			r0 = _mm_shuffle_epi32(prev, _MM_SHUFFLE(0,0,0,0));
			_mm_storeu_si128((__m128i*)&out[16], _mm_add_epi32(r1, r0));
			_mm_storeu_si128((__m128i*)&out[20], _mm_add_epi32(r5, r0));
			_mm_storeu_si128((__m128i*)&out[24], _mm_add_epi32(r9, r0));
			_mm_storeu_si128((__m128i*)&out[28], _mm_add_epi32(rD, r0));

			r4 = _mm_shuffle_epi32(prev, _MM_SHUFFLE(1, 1, 1, 1));
			r4 = _mm_add_epi32(r4, r0);
			_mm_storeu_si128((__m128i*)&out[32], _mm_add_epi32(r2, r4));
			_mm_storeu_si128((__m128i*)&out[36], _mm_add_epi32(r6, r4));
			_mm_storeu_si128((__m128i*)&out[40], _mm_add_epi32(rA, r4));
			_mm_storeu_si128((__m128i*)&out[44], _mm_add_epi32(rE, r4));

			r8 = _mm_shuffle_epi32(prev, _MM_SHUFFLE(2, 2, 2, 2));
			r8 = _mm_add_epi32(r8, r4);
			_mm_storeu_si128((__m128i*)&out[48], _mm_add_epi32(r3, r8));
			_mm_storeu_si128((__m128i*)&out[52], _mm_add_epi32(r7, r8));
			_mm_storeu_si128((__m128i*)&out[56], _mm_add_epi32(rB, r8));
			rF = _mm_add_epi32(rF, r8);
			_mm_storeu_si128((__m128i*)&out[60], rF);

			prev = rF;
			data_ptr += 16*16;
			out += 4*16;

		} while(key_ptr != end);

		// decode 4 elements per loop iteration
		for (uint32_t i = 0; i < ((count & 63) >> 2); i++) {
			__m128i data;
			size_t keys = *key_ptr++;
			SVB1_DECODE4(data, 0, keys << 4);
			data_ptr += 16;
			prev = _mm_delta_decode_epi32(data, prev);
			_mm_storeu_si128((__m128i*)out, prev);
			out += 4;
		}

		// prepare for scalar tail loop
		previous = (uint32_t)_mm_extract_epi32(prev, 3);
		count &= 3; // chunks of 4 are done
	}

	// scalar tail loop
	if (count != 0) {
		if (key_block_len >= 3) {
			data_ptr -= 4;
			size_t keys = 0;
			size_t i = 0;
			do {
				if ((i & 3) == 0) {
					keys = *key_ptr++;
				} else {
					keys >>= 2;
				}
				uint32_t dw;
				SVB1_DECODE1(keys & 3, data_ptr, dw);
				previous += dw;
				out[i] = previous;
			} while (++i < count);
			data_ptr += 4;
		} else {
			// no chunking
			size_t keys = svb_loadu_u16(key_ptr);
			for (uint32_t i = 0; i < count; i++) {
				uint32_t dw;
				SVB1_DECODE1_SAFE(keys & 3, data_ptr, dw);
				previous += dw;
				out[i] = previous;
				keys >>= 2;
			}
		}
	}
	return data_ptr;
}


#else

static inline
uint32_t _svb1_decode1_generic (const uint8_t* src, size_t key) {
	uint32_t r = src[0];
	switch (key){
		case 3:
			r |= src[1] << 8;
			r |= src[2] << 16;
			r |= src[3] << 24;
			break;
		case 2:
			r |= src[1] << 8;
			r |= src[2] << 16;
			break;
		case 1:
			r |= src[1] << 8;
			break;
		case 0:
			break;
	}
	return r;
}


const uint8_t* svb1_dec_generic (const uint8_t *restrict in,
	size_t count, uint32_t *restrict out)
{
	uint32_t key_block_len = _svb_key_block_len(count);
	const uint8_t *restrict key_ptr = in;
	const uint8_t *restrict data_ptr = &in[key_block_len];

	size_t keys = 0;
	for (size_t i = 0; i < count; i++) {
		if ((i & 3) == 0) {
			keys = *key_ptr++;
		}
		size_t code = keys & 3;
		keys >>= 2;
		out[i] = _svb1_decode1_generic(data_ptr, code);
		data_ptr += 1 + code;
	}
	return data_ptr;
}


const uint8_t* svb1z_dec_generic (const uint8_t *restrict in,
	size_t count, uint32_t *restrict out)
{
	uint32_t key_block_len = _svb_key_block_len(count);
	const uint8_t *restrict key_ptr = in;
	const uint8_t *restrict data_ptr = &in[key_block_len];

	size_t keys = 0;
	for (size_t i = 0; i < count; i++) {
		if ((i & 3) == 0) {
			keys = *key_ptr++;
		}
		size_t code = keys & 3;
		keys >>= 2;
		uint32_t dw = _svb1_decode1_generic(data_ptr, code);
		out[i] = _zigzag_decode_32(dw);
		data_ptr += 1 + code;
	}
	return data_ptr;
}


const uint8_t* svb1d_dec_generic (const uint8_t *restrict in,
	size_t count, uint32_t *restrict out, uint32_t previous)
{
	uint32_t key_block_len = _svb_key_block_len(count);
	const uint8_t *restrict key_ptr = in;
	const uint8_t *restrict data_ptr = &in[key_block_len];

	size_t keys = 0;
	for (size_t i = 0; i < count; i++) {
		if ((i & 3) == 0) {
			keys = *key_ptr++;
		}
		size_t code = keys & 3;
		keys >>= 2;
		uint32_t dw = _svb1_decode1_generic(data_ptr, code);
		previous = _delta_decode_32(dw, previous);
		out[i] = previous;
		data_ptr += 1 + code;
	}
	return data_ptr;
}


const uint8_t* svb1dz_dec_generic (const uint8_t *restrict in,
	size_t count, uint32_t *restrict out, uint32_t previous)
{
	uint32_t key_block_len = _svb_key_block_len(count);
	const uint8_t *restrict key_ptr = in;
	const uint8_t *restrict data_ptr = &in[key_block_len];

	size_t keys = 0;
	for (size_t i = 0; i < count; i++) {
		if ((i & 3) == 0) {
			keys = *key_ptr++;
		}
		size_t code = keys & 3;
		keys >>= 2;
		uint32_t dw = _svb1_decode1_generic(data_ptr, code);
		previous = _delta_zigzag_decode_32(dw, previous);
		out[i] = previous;
		data_ptr += 1 + code;
	}
	return data_ptr;
}


const uint8_t* svb1dt_dec_generic (const uint8_t *restrict in,
	size_t count, uint32_t *restrict out, uint32_t previous)
{
	uint32_t key_block_len = _svb_key_block_len(count);
	const uint8_t *restrict key_ptr = in;
	const uint8_t *restrict data_ptr = &in[key_block_len];

	if ((count & ~63) != 0 ) {
		const uint8_t *end = &key_ptr[(count & ~63) >> 2];
		do { // for chunks of 64 elements
			for (size_t i = 0; i < 16; i++) { // 1st pass
				size_t keys = key_ptr[i];
				for (size_t j = 0; j < 64; j += 16) {
					size_t code = keys & 3;
					keys >>= 2;
					out[i+j] = _svb1_decode1_generic(data_ptr, code);
					data_ptr += 1 + code;
				}
			}
			for (size_t i = 0; i < 64; i++) { // 2nd pass
				previous = _delta_decode_32(out[i], previous);
				out[i] = previous;
			}
			key_ptr += 16;
			out += 64;
		} while (end != key_ptr);
		count &= 63;
	}

	// un-delta (no transpose) any remaining elements
	size_t keys = 0;
	for (size_t i = 0; i < count; i++) {
		if ((i & 3) == 0) {
			keys = *key_ptr++;
		}
		size_t code = keys & 3;
		keys >>= 2;
		uint32_t dw = _svb1_decode1_generic(data_ptr, code);
		previous = _delta_decode_32(dw, previous);
		out[i] = previous;
		data_ptr += 1 + code;
	}
	return data_ptr;
}


#endif // defined(__SSE4_1__) || defined(__AVX__)
